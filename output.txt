

// .\package.json
{
  "name": "vite-project",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "start:dev": "vite --host 0.0.0.0 --port 8080",
    "supabase:init": "supabase init",
    "supabase:start": "supabase start",
    "supabase:stop": "supabase stop",
    "supabase:status": "supabase status",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "devDependencies": {
    "@types/react": "^18.3.10",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.2",
    "eslint": "^8.57.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.12",
    "supabase": "^1.204.0",
    "vite": "^5.4.8"
  },
  "dependencies": {
    "@axe-core/react": "^4.10.0",
    "@chakra-ui/icons": "^2.1.1",
    "@chakra-ui/react": "^2.8.2",
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@hookform/resolvers": "^3.9.0",
    "@react-google-maps/api": "^2.19.3",
    "@sentry/react": "^7.119.1",
    "@sentry/tracing": "^7.108.0",
    "@stripe/react-stripe-js": "^2.8.0",
    "@stripe/stripe-js": "^4.5.0",
    "@supabase/auth-ui-react": "^0.4.7",
    "@supabase/auth-ui-shared": "^0.1.8",
    "@supabase/supabase-js": "^2.45.4",
    "@tanstack/react-query": "^5.59.0",
    "@tanstack/react-query-devtools": "^5.0.0",
    "axios": "^1.7.7",
    "axios-retry": "^3.9.1",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.1",
    "express-rate-limit": "^7.4.1",
    "express-validator": "^7.2.0",
    "framer-motion": "^11.9.0",
    "fs": "^0.0.1-security",
    "globby": "^14.0.2",
    "jest": "^29.7.0",
    "k6": "^0.0.0",
    "leaflet": "^1.9.4",
    "lodash": "^4.17.21",
    "react": "^18.3.1",
    "react-datepicker": "^7.4.0",
    "react-dom": "^18.3.1",
    "react-ga4": "^2.1.0",
    "react-helmet": "^6.1.0",
    "react-hook-form": "^7.53.0",
    "react-icons": "^5.3.0",
    "react-leaflet": "^4.2.1",
    "react-router-dom": "^6.26.2",
    "stripe": "^17.0.0",
    "uuid": "^10.0.0",
    "winston": "^3.14.2",
    "yup": "^1.4.0"
  },
  "prettier": {
    "printWidth": 100
  }
}



// .\tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "types": ["vite/client"]
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\package.json
{
  "name": "vite-project",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "start:dev": "vite --host 0.0.0.0 --port 8080",
    "supabase:init": "supabase init",
    "supabase:start": "supabase start",
    "supabase:stop": "supabase stop",
    "supabase:status": "supabase status",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "devDependencies": {
    "@types/react": "^18.3.10",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.2",
    "eslint": "^8.57.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.12",
    "supabase": "^1.204.0",
    "vite": "^5.4.8"
  },
  "dependencies": {
    "@axe-core/react": "^4.10.0",
    "@chakra-ui/icons": "^2.1.1",
    "@chakra-ui/react": "^2.8.2",
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@hookform/resolvers": "^3.9.0",
    "@react-google-maps/api": "^2.19.3",
    "@sentry/react": "^7.119.1",
    "@sentry/tracing": "^7.108.0",
    "@stripe/react-stripe-js": "^2.8.0",
    "@stripe/stripe-js": "^4.5.0",
    "@supabase/auth-ui-react": "^0.4.7",
    "@supabase/auth-ui-shared": "^0.1.8",
    "@supabase/supabase-js": "^2.45.4",
    "@tanstack/react-query": "^5.59.0",
    "@tanstack/react-query-devtools": "^5.0.0",
    "axios": "^1.7.7",
    "axios-retry": "^3.9.1",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.1",
    "express-rate-limit": "^7.4.1",
    "express-validator": "^7.2.0",
    "framer-motion": "^11.9.0",
    "fs": "^0.0.1-security",
    "globby": "^14.0.2",
    "jest": "^29.7.0",
    "k6": "^0.0.0",
    "leaflet": "^1.9.4",
    "lodash": "^4.17.21",
    "react": "^18.3.1",
    "react-datepicker": "^7.4.0",
    "react-dom": "^18.3.1",
    "react-ga4": "^2.1.0",
    "react-helmet": "^6.1.0",
    "react-hook-form": "^7.53.0",
    "react-icons": "^5.3.0",
    "react-leaflet": "^4.2.1",
    "react-router-dom": "^6.26.2",
    "stripe": "^17.0.0",
    "uuid": "^10.0.0",
    "winston": "^3.14.2",
    "yup": "^1.4.0"
  },
  "prettier": {
    "printWidth": 100
  }
}



// C:\Users\israe\Documents\GitHub\grua-booking-system1\supabase.ts
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      bookings: {
        Row: {
          id: string
          user_id: string
          service_id: string
          status: Database["public"]["Enums"]["booking_status"]
          payment_status: Database["public"]["Enums"]["payment_status"]
          pickup_location: string
          dropoff_location: string
          vehicle_details: Json
          distance: number
          total_cost: number
          pickup_datetime: string
          additional_details: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          user_id: string
          service_id: string
          status?: Database["public"]["Enums"]["booking_status"]
          payment_status?: Database["public"]["Enums"]["payment_status"]
          pickup_location: string
          dropoff_location: string
          vehicle_details: Json
          distance: number
          total_cost: number
          pickup_datetime: string
          additional_details?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          service_id?: string
          status?: Database["public"]["Enums"]["booking_status"]
          payment_status?: Database["public"]["Enums"]["payment_status"]
          pickup_location?: string
          dropoff_location?: string
          vehicle_details?: Json
          distance?: number
          total_cost?: number
          pickup_datetime?: string
          additional_details?: string | null
          created_at?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "bookings_service_id_fkey"
            columns: ["service_id"]
            referencedRelation: "services"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "bookings_user_id_fkey"
            columns: ["user_id"]
            referencedRelation: "users"
            referencedColumns: ["id"]
          }
        ]
      }
      password_failed_verification_attempts: {
        Row: {
          last_failed_at: string
          user_id: string
        }
        Insert: {
          last_failed_at: string
          user_id: string
        }
        Update: {
          last_failed_at?: string
          user_id?: string
        }
        Relationships: []
      }
      profiles: {
        Row: {
          avatar_url: string | null
          full_name: string | null
          id: string
          updated_at: string | null
          username: string | null
          website: string | null
        }
        Insert: {
          avatar_url?: string | null
          full_name?: string | null
          id: string
          updated_at?: string | null
          username?: string | null
          website?: string | null
        }
        Update: {
          avatar_url?: string | null
          full_name?: string | null
          id?: string
          updated_at?: string | null
          username?: string | null
          website?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "profiles_id_fkey"
            columns: ["id"]
            isOneToOne: true
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      services: {
        Row: {
          base_price: number
          created_at: string
          description: string | null
          id: string
          maneuver_charge: number
          name: string
          price_per_km: number
          tow_truck_type: Database["public"]["Enums"]["tow_truck_type"]
          updated_at: string
        }
        Insert: {
          base_price: number
          created_at?: string
          description?: string | null
          id?: string
          maneuver_charge: number
          name: string
          price_per_km: number
          tow_truck_type: Database["public"]["Enums"]["tow_truck_type"]
          updated_at?: string
        }
        Update: {
          base_price?: number
          created_at?: string
          description?: string | null
          id?: string
          maneuver_charge?: number
          name?: string
          price_per_km?: number
          tow_truck_type?: Database["public"]["Enums"]["tow_truck_type"]
          updated_at?: string
        }
        Relationships: []
      }
      smtp_settings: {
        Row: {
          created_at: string
          from_email: string | null
          from_name: string | null
          id: string
          is_custom_smtp: boolean
          smtp_host: string | null
          smtp_password: string | null
          smtp_port: number | null
          smtp_user: string | null
          updated_at: string
          user_id: string | null
        }
        Insert: {
          created_at?: string
          from_email?: string | null
          from_name?: string | null
          id?: string
          is_custom_smtp?: boolean
          smtp_host?: string | null
          smtp_password?: string | null
          smtp_port?: number | null
          smtp_user?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Update: {
          created_at?: string
          from_email?: string | null
          from_name?: string | null
          id?: string
          is_custom_smtp?: boolean
          smtp_host?: string | null
          smtp_password?: string | null
          smtp_port?: number | null
          smtp_user?: string | null
          updated_at?: string
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "smtp_settings_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      users: {
        Row: {
          created_at: string
          email: string
          encrypted_password: string
          id: string
          role: Database["public"]["Enums"]["user_role"]
          updated_at: string
        }
        Insert: {
          created_at?: string
          email: string
          encrypted_password: string
          id?: string
          role?: Database["public"]["Enums"]["user_role"]
          updated_at?: string
        }
        Update: {
          created_at?: string
          email?: string
          encrypted_password?: string
          id?: string
          role?: Database["public"]["Enums"]["user_role"]
          updated_at?: string
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      custom_access_token_hook: {
        Args: {
          event: Json
        }
        Returns: Json
      }
      get_current_user_id: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      hook_password_verification_attempt: {
        Args: {
          event: Json
        }
        Returns: Json
      }
    }
    Enums: {
      booking_status: "pending" | "confirmed" | "in_progress" | "completed" | "cancelled"
      payment_status: "pending" | "paid" | "failed" | "refunded"
      tow_truck_type: "flatbed" | "wheel_lift" | "integrated" | "heavy_duty"
      user_role: "user" | "admin" | "super_admin"
      vehicle_size: "small" | "medium" | "large"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type PublicSchema = Database[Extract<keyof Database, "public">]

export type Tables<
  PublicTableNameOrOptions extends
    | keyof (PublicSchema["Tables"] & PublicSchema["Views"])
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
        Database[PublicTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
      Database[PublicTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : PublicTableNameOrOptions extends keyof (PublicSchema["Tables"] &
        PublicSchema["Views"])
    ? (PublicSchema["Tables"] &
        PublicSchema["Views"])[PublicTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  PublicEnumNameOrOptions extends
    | keyof PublicSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = PublicEnumNameOrOptions extends { schema: keyof Database }
  ? Database[PublicEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : PublicEnumNameOrOptions extends keyof PublicSchema["Enums"]
    ? PublicSchema["Enums"][PublicEnumNameOrOptions]
    : never




// C:\Users\israe\Documents\GitHub\grua-booking-system1\tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "types": ["vite/client"]
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\tsconfig.node.json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'), // Enables importing from 'src' as '@'
    },
  },
  server: {
    host: '::',
    port: '8080',
    strictPort: true,
    clearScreen: false,
  },
  plugins: [react()],
});



// C:\Users\israe\Documents\GitHub\grua-booking-system1\.gpt_engineer_internals\report-url-change.js
const main = () => {
  /**
   * Function to send a message to parent windows
   */
  const postUrlChange = (newUrl) => {
    try {
      const message = { type: "URL_CHANGED", url: newUrl };
      window.top.postMessage(message, "https://run.gptengineer.app");
      window.top.postMessage(message, "http://localhost:3000");
      window.top.postMessage(message, window.origin);
    } catch (error) {
      console.error("Error posting URL change:", error);
    }
  };

  /**
   * Listen for URL changes using MutationObserver and navigation-related events.
   */
  const observeUrlChange = () => {
    let oldHref = document.location.href;

    const checkUrlChange = () => {
      const newHref = document.location.href;
      if (oldHref !== newHref) {
        oldHref = newHref;
        postUrlChange(newHref); // Call the function to post the URL change
      }
    };

    // Observe DOM changes (Fallback for cases not covered by events)
    const body = document.querySelector("body");
    const observer = new MutationObserver(checkUrlChange);
    observer.observe(body, { childList: true, subtree: true });

    // Add event listeners for navigation-related changes
    window.addEventListener("popstate", checkUrlChange); // Back/forward button
    window.addEventListener("hashchange", checkUrlChange); // Hash changes (e.g., #section)

    // Monkey patch pushState and replaceState to capture URL changes triggered by them
    const originalPushState = history.pushState;
    history.pushState = function () {
      originalPushState.apply(this, arguments);
      checkUrlChange();
    };

    const originalReplaceState = history.replaceState;
    history.replaceState = function () {
      originalReplaceState.apply(this, arguments);
      checkUrlChange();
    };
  };

  // Run observeUrlChange when the window is loaded
  window.addEventListener("load", observeUrlChange);
};

// Execute main function (No need for .catch() as this is synchronous)
main();



// C:\Users\israe\Documents\GitHub\grua-booking-system1\.vscode\extensions.json
{
  "recommendations": ["denoland.vscode-deno"]
}



// C:\Users\israe\Documents\GitHub\grua-booking-system1\.vscode\launch.json
{
    // Use IntelliSense para saber los atributos posibles.
    // Mantenga el puntero para ver las descripciones de los existentes atributos.
    // Para más información, visite: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "PowerShell: Launch Current File",
            "type": "PowerShell",
            "request": "launch",
            "script": "${file}",
            "args": []
        }
    ]
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\notifications\index.js
const express = require('express');
const Redis = require('ioredis');

const app = express();
const redis = new Redis(process.env.REDIS_URL || 'redis://redis:6379');

app.use(express.json());

app.post('/notify', async (req, res) => {
  const { message } = req.body;
  await redis.publish('notifications', JSON.stringify(message));
  res.status(200).json({ status: 'Notification sent' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Notifications service running on port ${PORT}`));


// C:\Users\israe\Documents\GitHub\grua-booking-system1\scripts\update-package-json.js
const fs = require('fs');
const path = require('path');

const packageJsonPath = path.join(__dirname, '..', 'package.json');

try {
  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));

  if (!packageJson.scripts['build:dev']) {
    packageJson.scripts['build:dev'] = 'vite build --mode development';

    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    console.log('Successfully added build:dev script to package.json');
  } else {
    console.log('build:dev script already exists in package.json');
  }
} catch (error) {
  console.error('Error updating package.json:', error);

  // Replace process.exit(1) with more browser-friendly error handling
  if (typeof window === 'undefined') {
    // Node.js environment
    process.exit(1);
  } else {
    // Browser environment or other runtime
    throw new Error('Failed to update package.json');
  }
}



// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\App.tsx
import React from 'react';
import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
import { ChakraProvider, extendTheme } from '@chakra-ui/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { SupabaseProvider } from './integrations/supabase';
import { SupabaseAuthProvider } from './integrations/supabase/auth';
import Index from './pages/Index';
import About from './pages/About';
import Contact from './pages/Contact';
import AdminPanel from './pages/AdminPanel';
import ProtectedRoute from './components/common/ProtectedRoute';
import Login from './pages/Login';
import ErrorBoundary from './components/ErrorBoundary';
import BookingPage from './pages/BookingForm';
import Layout from './components/layout/Layout';

const queryClient = new QueryClient();

const theme = extendTheme({
  styles: {
    global: {
      body: {
        bg: 'linear-gradient(135deg, #0f2027, #203a43, #2c5364)',
        color: 'white',
      },
    },
  },
  components: {
    Button: {
      baseStyle: {
        _hover: {
          transform: 'translateY(-2px)',
          boxShadow: '0 0 15px rgba(0, 150, 255, 0.5)',
        },
        transition: 'all 0.3s',
        position: 'relative',
        overflow: 'hidden',
        _before: {
          content: '""',
          position: 'absolute',
          top: '-50%',
          left: '-50%',
          width: '200%',
          height: '200%',
          background: 'linear-gradient(45deg, transparent, rgba(0, 150, 255, 0.3), transparent)',
          transform: 'rotate(45deg)',
          transition: 'all 0.3s',
        },
      },
    },
  },
});

const App = () => {
  return (
    <ChakraProvider theme={theme}>
      <ErrorBoundary>
        <QueryClientProvider client={queryClient}>
          <SupabaseProvider>
            <SupabaseAuthProvider>
              <Router>
                <Layout>
                  <Routes>
                    <Route path="/" element={<Index />} />
                    <Route path="/about" element={<About />} />
                    <Route path="/contact" element={<Contact />} />
                    <Route path="/login" element={<Login />} />
                    <Route path="/booking" element={<BookingPage />} />
                    <Route 
                      path="/admin" 
                      element={
                        <ProtectedRoute adminOnly>
                          <AdminPanel />
                        </ProtectedRoute>
                      } 
                    />
                  </Routes>
                </Layout>
              </Router>
            </SupabaseAuthProvider>
          </SupabaseProvider>
        </QueryClientProvider>
      </ErrorBoundary>
    </ChakraProvider>
  );
};

export default App;


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\setupSampleData.js
import { resetAndInsertSampleData } from './utils/insertSampleData';

const setupSampleData = async () => {
  try {
    await resetAndInsertSampleData();
    console.log('Database reset and sample data setup complete');
  } catch (error) {
    console.error('Error resetting database and setting up sample data:', error);
  }
};

setupSampleData();


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\theme.js
import { extendTheme } from "@chakra-ui/react";

const theme = extendTheme({
  styles: {
    global: {
      body: {
        bg: 'linear-gradient(135deg, #0f2027, #203a43, #2c5364)',
        color: 'white',
      },
    },
  },
  components: {
    Button: {
      baseStyle: {
        _hover: {
          transform: 'translateY(-2px)',
          boxShadow: '0 0 15px rgba(0, 150, 255, 0.5)',
        },
        transition: 'all 0.3s',
        position: 'relative',
        overflow: 'hidden',
        _before: {
          content: '""',
          position: 'absolute',
          top: '-50%',
          left: '-50%',
          width: '200%',
          height: '200%',
          background: 'linear-gradient(45deg, transparent, rgba(0, 150, 255, 0.3), transparent)',
          transform: 'rotate(45deg)',
          transition: 'all 0.3s',
        },
        _hover: {
          _before: {
            left: '100%',
          },
        },
      },
    },
  },
});

export default theme;


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\vite-env.d.ts
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_SUPABASE_PROJECT_URL: string
  readonly VITE_SUPABASE_API_KEY: string
  readonly VITE_GOOGLE_MAPS_API_KEY: string
  readonly VITE_STRIPE_PUBLISHABLE_KEY: string
  readonly VITE_GOOGLE_MAPS_ID: string
  // Add other environment variables as needed
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\authentication\authentication.domain.facade.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AuthenticationDomainFacade {
  private users: Map<string, string> = new Map();

  constructor() {
    // Initialize with some default users
    this.users.set('user1', 'password1');
    this.users.set('user2', 'password2');
  }

  public authenticate(username: string, password: string): boolean {
    const storedPassword = this.users.get(username);
    return storedPassword === password;
  }

  public addUser(username: string, password: string): void {
    this.users.set(username, password);
  }

  public removeUser(username: string): void {
    this.users.delete(username);
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\authentication\authentication.domain.module.ts
import { Module } from '@nestjs/common';
import { AuthenticationDomainFacade } from './authentication.domain.facade';

@Module({
  providers: [AuthenticationDomainFacade],
  exports: [AuthenticationDomainFacade],
})
export class AuthenticationDomainModule {}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\config\stripe.js
import { loadStripe } from '@stripe/stripe-js';

const stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY);

export default stripePromise;


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\config\supabase.config.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_PROJECT_URL;
const supabaseKey = import.meta.env.VITE_SUPABASE_API_KEY;

if (!supabaseUrl || !supabaseKey) {
  throw new Error('Missing Supabase environment variables. Please check your .env file.');
}

export const supabase = createClient(supabaseUrl, supabaseKey);

export const getUserRole = async (userId: string) => {
  try {
    const { data, error } = await supabase
      .from('users')
      .select('role')
      .eq('id', userId)
      .single();

    if (error) {
      console.error('Error fetching user role:', error);
      return null;
    }

    return data?.role || null;
  } catch (error) {
    console.error('Error fetching user role:', error);
    return null;
  }
};

export default supabase;


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\config\supabaseClient.js
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_PROJECT_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_API_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables. Please check your .env file.');
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);

// Function to get user role
export async function getUserRole(userId) {
  const { data, error } = await supabase
    .from('users')
    .select('role')
    .eq('id', userId)
    .single();

  if (error) {
    console.error('Error fetching user role:', error);
    return null; // Handle the error appropriately
  }

  if (!data) {
    console.warn(`No user found with id: ${userId}`);
    return null; // Handle the case where the user is not found
  }

  return data.role;
}

export default supabase;


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\constants\roles.js
export const ROLES = {
  USER: 'user',
  ADMIN: 'admin',
  SUPER_ADMIN: 'super_admin'
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\event\event.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class EventService {
  private events: any[] = [];

  emit(event: any) {
    this.events.push(event);
    console.log('Event emitted:', event);
  }

  getEvents() {
    return this.events;
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\hooks\useBookingForm.js
import { useState, useCallback, useEffect } from 'react';
import { useToast } from "@chakra-ui/react";
import { useNavigate } from "react-router-dom";
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useSupabaseAuth } from '../integrations/supabase/auth';
import { createBooking, saveDraftBooking } from '../server/db';
import { testPayment } from '../utils/testPayment';
import { getVehicleSize, getTowTruckType, calculateTotalCost } from '../utils/towTruckSelection';

export const useBookingForm = () => {
  const [formData, setFormData] = useState(() => {
    const savedData = localStorage.getItem('bookingFormData');
    return savedData ? JSON.parse(savedData, (key, value) => {
      if (key === 'pickupDateTime') return new Date(value);
      return value;
    }) : {
      serviceType: '',
      userName: '',
      phoneNumber: '',
      vehicleBrand: '',
      vehicleModel: '',
      vehicleColor: '',
      licensePlate: '',
      vehicleSize: '',
      pickupAddress: '',
      dropOffAddress: '',
      vehicleIssue: '',
      additionalDetails: '',
      wheelsStatus: '',
      pickupDateTime: new Date(),
      paymentMethod: 'card',
      vehiclePosition: '',
      inNeutral: false,
      engineStarts: false,
      wheelsSteer: false,
    };
  });

  const [distance, setDistance] = useState(0);
  const [totalCost, setTotalCost] = useState(0);
  const [isPaymentWindowOpen, setIsPaymentWindowOpen] = useState(false);

  const navigate = useNavigate();
  const { session } = useSupabaseAuth();
  const toast = useToast();
  const queryClient = useQueryClient();

  const createBookingMutation = useMutation({
    mutationFn: createBooking,
    onSuccess: () => {
      queryClient.invalidateQueries('bookings');
      toast({
        title: 'Booking created.',
        description: "Your booking has been created successfully.",
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
      navigate('/confirmation');
    },
    onError: (error) => {
      console.error('Error creating booking:', error);
      toast({
        title: 'An error occurred.',
        description: error.message || 'There was an error processing your request. Please try again.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    },
  });

  const saveDraft = useCallback(async (draftData) => {
    if (!session) {
      toast({
        title: 'Authentication required',
        description: 'Please log in to save a draft.',
        status: 'warning',
        duration: 5000,
        isClosable: true,
      });
      return false;
    }

    try {
      await saveDraftBooking({
        ...draftData,
        userId: session.user.id,
        totalCost,
        distance,
      });
      return true;
    } catch (error) {
      console.error('Error saving draft:', error);
      return false;
    }
  }, [session, totalCost, distance, toast]);

  const handleChange = useCallback((e) => {
    const { name, value } = e.target;
    setFormData(prevData => ({
      ...prevData,
      [name]: value
    }));

    if (name === 'vehicleBrand') {
      setFormData(prevData => ({
        ...prevData,
        vehicleModel: ''
      }));
    }

    if (name === 'vehicleModel' || name === 'vehiclePosition') {
      updateTotalCost();
    }
  }, []);

  const updateTotalCost = useCallback(() => {
    const vehicleSize = getVehicleSize(formData.vehicleModel);
    const towTruckType = getTowTruckType(vehicleSize);
    const requiresManeuver = formData.vehiclePosition === 'obstructed';
    const cost = calculateTotalCost(distance, towTruckType, requiresManeuver);
    setTotalCost(cost);
  }, [formData.vehicleModel, formData.vehiclePosition, distance]);

  const handleDateTimeChange = useCallback((date) => {
    setFormData(prevData => ({
      ...prevData,
      pickupDateTime: date
    }));
  }, []);

  const handleBookingProcess = useCallback(async (data) => {
    if (!session) {
      toast({
        title: 'Authentication required',
        description: 'Please log in to create a booking.',
        status: 'warning',
        duration: 5000,
        isClosable: true,
      });
      return;
    }

    try {
      const testResult = await testPayment(totalCost);
      if (!testResult.success) {
        throw new Error(testResult.message || 'Payment test failed');
      }

      await createBookingMutation.mutateAsync({
        ...data,
        userId: session.user.id,
        totalCost,
        distance,
        additional_details: data.additionalDetails || '',
      });
    } catch (error) {
      console.error('Error processing booking:', error);
      toast({
        title: 'Booking Error',
        description: error.message || 'There was an error processing your request. Please try again.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    }
  }, [session, totalCost, distance, createBookingMutation, toast]);

  useEffect(() => {
    localStorage.setItem('bookingFormData', JSON.stringify(formData));
  }, [formData]);

  useEffect(() => {
    updateTotalCost();
  }, [updateTotalCost, distance]);

  return {
    formData,
    setFormData,
    distance,
    setDistance,
    totalCost,
    setTotalCost,
    isPaymentWindowOpen,
    setIsPaymentWindowOpen,
    handleChange,
    handleDateTimeChange,
    handleBookingProcess,
    isLoading: createBookingMutation.isLoading,
    saveDraft,
  };
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\hooks\useBookings.js
import { useQuery } from '@tanstack/react-query';
import { getBookings } from '../server/db';
import { useToast } from '@chakra-ui/react';
import { logError } from '../utils/monitoring';

export const useBookings = (page = 1, limit = 50) => {
  const toast = useToast();

  return useQuery({
    queryKey: ['bookings', page, limit],
    queryFn: async () => {
      try {
        const result = await getBookings(Number(page), Number(limit));
        return result;
      } catch (error) {
        console.error('Error fetching bookings:', error);
        logError(error);
        toast({
          title: 'Error fetching bookings',
          description: 'Please try again later or contact support if the problem persists.',
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
        throw error;
      }
    },
    staleTime: 60000, // 1 minute
    cacheTime: 5 * 60 * 1000, // 5 minutes
    refetchInterval: 300000, // 5 minutes
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\hooks\useMapRouteLogic.js
import { useState, useCallback, useEffect } from 'react';
import { useToast } from '@chakra-ui/react';
import { calculateTotalCost, getTowTruckType } from '../utils/towTruckSelection';

export const useMapRouteLogic = (setPickupAddress, setDropOffAddress, setDistance, setTotalCost, vehicleSize) => {
  const [pickup, setPickup] = useState(null);
  const [destination, setDestination] = useState(null);
  const [map, setMap] = useState(null);
  const [route, setRoute] = useState(null);
  const companyLocation = [26.509672, -100.0095504];
  const toast = useToast();

  const getAddressFromLatLng = useCallback(async (lat, lng) => {
    try {
      const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`);
      if (!response.ok) throw new Error('No se pudo obtener la dirección');
      const data = await response.json();
      return data.display_name;
    } catch (error) {
      console.error('Error al obtener la dirección:', error);
      toast({
        title: 'Error de dirección',
        description: 'No se pudo obtener la dirección. Por favor, intente de nuevo.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return '';
    }
  }, [toast]);

  const handleMapClick = useCallback(async (e) => {
    try {
      const { lat, lng } = e.latlng;
      if (!pickup) {
        setPickup([lat, lng]);
        const address = await getAddressFromLatLng(lat, lng);
        setPickupAddress(address);
        toast({
          title: 'Punto de recogida seleccionado',
          description: 'Ahora seleccione el punto de destino',
          status: 'info',
          duration: 3000,
          isClosable: true,
        });
      } else if (!destination) {
        setDestination([lat, lng]);
        const address = await getAddressFromLatLng(lat, lng);
        setDropOffAddress(address);
        toast({
          title: 'Destino seleccionado',
          description: 'Ruta calculada',
          status: 'success',
          duration: 3000,
          isClosable: true,
        });
      }
    } catch (error) {
      console.error('Error al manejar el clic en el mapa:', error);
      toast({
        title: 'Error',
        description: 'No se pudo procesar el clic en el mapa. Por favor, intente de nuevo.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    }
  }, [pickup, destination, setPickupAddress, setDropOffAddress, toast, getAddressFromLatLng]);

  const handleMarkerDrag = useCallback(async (e, isPickup) => {
    try {
      const { lat, lng } = e.target.getLatLng();
      const address = await getAddressFromLatLng(lat, lng);
      if (isPickup) {
        setPickup([lat, lng]);
        setPickupAddress(address);
      } else {
        setDestination([lat, lng]);
        setDropOffAddress(address);
      }
    } catch (error) {
      console.error('Error al manejar el arrastre del marcador:', error);
      toast({
        title: 'Error',
        description: 'No se pudo actualizar la posición del marcador. Por favor, intente de nuevo.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    }
  }, [setPickupAddress, setDropOffAddress, toast, getAddressFromLatLng]);

  const calculateRoute = useCallback(async () => {
    if (pickup && destination) {
      try {
        const fullRoute = `${companyLocation[1]},${companyLocation[0]};${pickup[1]},${pickup[0]};${destination[1]},${destination[0]};${companyLocation[1]},${companyLocation[0]}`;
        const response = await fetch(`https://router.project-osrm.org/route/v1/driving/${fullRoute}?overview=full&geometries=geojson`);
        if (!response.ok) throw new Error('No se pudo calcular la ruta');
        const data = await response.json();
        if (data.routes && data.routes.length > 0) {
          setRoute(data.routes[0].geometry.coordinates);
          const distanceInMeters = data.routes[0].distance;
          const distanceInKm = distanceInMeters / 1000;
          setDistance(distanceInKm);
          const towTruckType = getTowTruckType(vehicleSize);
          const cost = calculateTotalCost(distanceInKm, towTruckType);
          setTotalCost(cost);
          toast({
            title: 'Ruta calculada',
            description: `Distancia total: ${distanceInKm.toFixed(2)} km`,
            status: 'success',
            duration: 5000,
            isClosable: true,
          });
        }
      } catch (error) {
        console.error('Error al calcular la ruta:', error);
        toast({
          title: 'Error de ruta',
          description: 'No se pudo calcular la ruta. Por favor, intente de nuevo.',
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
      }
    }
  }, [pickup, destination, setDistance, setTotalCost, vehicleSize, toast, companyLocation]);

  useEffect(() => {
    calculateRoute();
  }, [calculateRoute]);

  const resetMap = useCallback(() => {
    setPickup(null);
    setDestination(null);
    setPickupAddress('');
    setDropOffAddress('');
    setDistance(0);
    setTotalCost(0);
    setRoute(null);
    if (map) {
      map.setView(companyLocation, 10);
    }
    toast({
      title: 'Mapa reiniciado',
      description: 'Seleccione nuevos puntos de recogida y destino',
      status: 'info',
      duration: 3000,
      isClosable: true,
    });
  }, [map, setPickupAddress, setDropOffAddress, setDistance, setTotalCost, toast, companyLocation]);

  return {
    pickup,
    destination,
    route,
    companyLocation,
    handleMapClick,
    handleMarkerDrag,
    setMap,
    resetMap
  };
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\hooks\usePaymentProcessing.js
import { useToast } from "@chakra-ui/react";

export const usePaymentProcessing = (formData, totalCost, setIsPaymentWindowOpen, navigate) => {
  const toast = useToast();

  const handlePaymentSubmit = async (paymentResult) => {
    try {
      if (paymentResult.success) {
        // Process successful payment
        setIsPaymentWindowOpen(false);
        toast({
          title: "Payment Successful",
          description: "Your payment has been processed successfully.",
          status: "success",
          duration: 5000,
          isClosable: true,
        });
        navigate('/confirmation', { state: { bookingData: formData } });
      } else {
        throw new Error(paymentResult.error || 'Payment processing failed');
      }
    } catch (error) {
      console.error('Error finalizing booking:', error);
      toast({
        title: "Payment Error",
        description: error.message || "There was an error processing your payment. Please try again.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    }
  };

  return { handlePaymentSubmit };
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\hooks\usePaymentSubmit.js
import { useCallback } from 'react';
import { useToast } from "@chakra-ui/react";
import { useQueryClient } from '@tanstack/react-query';
import { useSupabaseAuth } from '../integrations/supabase/auth';
import { sendAdminNotification } from '../utils/adminNotification';

export const usePaymentSubmit = (formData, totalCost, createBookingMutation, setIsPaymentWindowOpen) => {
  const { session } = useSupabaseAuth();
  const toast = useToast();
  const queryClient = useQueryClient();

  const handlePaymentSubmit = useCallback(async (paymentMethod) => {
    setIsPaymentWindowOpen(false);

    try {
      const response = await fetch('/api/process-payment', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          paymentMethodId: paymentMethod.id,
          amount: totalCost * 100, // Convert to cents
        }),
      });

      if (!response.ok) {
        throw new Error('Payment processing failed');
      }

      const result = await response.json();

      if (result.success) {
        const bookingData = {
          ...formData,
          userId: session?.user?.id || 'test_user_id',
          totalCost,
          paymentIntentId: result.paymentIntentId,
          status: 'paid',
          payment_status: 'paid'
        };

        try {
          await createBookingMutation.mutateAsync(bookingData);
          await sendAdminNotification(bookingData, totalCost);

          toast({
            title: 'Booking Confirmed',
            description: 'Your booking has been successfully created and payment processed.',
            status: 'success',
            duration: 5000,
            isClosable: true,
          });

          queryClient.invalidateQueries('bookings');
        } catch (bookingError) {
          console.error('Error creating booking:', bookingError);
          toast({
            title: 'Booking Error',
            description: 'Your payment was successful, but there was an issue creating your booking. Our team has been notified and will contact you shortly.',
            status: 'warning',
            duration: 7000,
            isClosable: true,
          });
        }
      } else {
        throw new Error('Payment processing failed');
      }
    } catch (error) {
      console.error('Payment Error:', error);
      toast({
        title: 'Payment Error',
        description: 'We encountered an issue processing your payment. Please try again or contact our support team.',
        status: 'error',
        duration: 7000,
        isClosable: true,
      });
    }
  }, [formData, session, totalCost, createBookingMutation, toast, queryClient, setIsPaymentWindowOpen]);

  return handlePaymentSubmit;
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\hooks\useServices.js
import { useQuery } from '@tanstack/react-query';
import { getServices } from '../server/db';
import { useToast } from '@chakra-ui/react';

export const useServices = () => {
  const toast = useToast();

  return useQuery({
    queryKey: ['services'],
    queryFn: async () => {
      try {
        const services = await getServices();
        return services;
      } catch (error) {
        console.error('Failed to fetch services:', error);
        toast({
          title: 'Error fetching services',
          description: `${error.message}. Please try again later or contact support if the problem persists.`,
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
        throw error;
      }
    },
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    refetchOnWindowFocus: false,
    onError: (error) => {
      console.error('React Query error:', error);
    },
  });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\hooks\useUsers.js
import { useQuery } from '@tanstack/react-query';
import { getUsers } from '../server/db';
import { useToast } from '@chakra-ui/react';

export const useUsers = () => {
  const toast = useToast();

  return useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      try {
        const users = await getUsers();
        if (!Array.isArray(users)) {
          throw new Error('Invalid response format');
        }
        return users;
      } catch (error) {
        console.error('Failed to fetch users:', error);
        toast({
          title: 'Error fetching users',
          description: 'Please try again later or contact support if the problem persists.',
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
        throw error;
      }
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
    cacheTime: 30 * 60 * 1000, // 30 minutes
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\integrations\supabase\auth.tsx
import React, { useState, useEffect, createContext, useContext, ReactNode } from 'react';
import { Session } from '@supabase/supabase-js';
import { User } from '@supabase/supabase-js';
import { useQueryClient } from 'react-query';
import { supabase } from '../../config/supabase.config';

interface SupabaseAuthContextType {
  session: Session | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<any>;
  logout: () => Promise<void>;
}

const SupabaseAuthContext = createContext<SupabaseAuthContextType | undefined>(undefined);

export const SupabaseAuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);
  const queryClient = useQueryClient();

  useEffect(() => {
    const getSession = async () => {
      setLoading(true);
      const { data: { session } } = await supabase.auth.getSession();
      setSession(session);
      setLoading(false);
    };

    getSession();

    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session);
      queryClient.invalidateQueries(['user']);
    });

    return () => {
      authListener.subscription.unsubscribe();
    };
  }, [queryClient]);

  const login = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) throw error;
    setSession(data.session);
    return data;
  };

  const logout = async () => {
    await supabase.auth.signOut();
    setSession(null);
    queryClient.invalidateQueries(['user']);
  };

  return (
    <SupabaseAuthContext.Provider value={{ session, loading, login, logout }}>
      {children}
    </SupabaseAuthContext.Provider>
  );
};

export const useSupabaseAuth = (): SupabaseAuthContextType => {
  const context = useContext(SupabaseAuthContext);
  if (context === undefined) {
    throw new Error('useSupabaseAuth must be used within a SupabaseAuthProvider');
  }
  return context;
};



// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\integrations\supabase\index.js
// Import all the relevant exports from other files in the supabase directory
import { supabase } from './supabase.js';
import { SupabaseAuthProvider, useSupabaseAuth, SupabaseAuthUI } from './auth.jsx';

// Export all the imported functions and objects from .auth and .hooks/
export {
  supabase,
  SupabaseAuthProvider,
  useSupabaseAuth,
  SupabaseAuthUI,
};



// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\integrations\supabase\openapi.json
{"swagger":"2.0","info":{"description":"","title":"standard public schema","version":"12.2.3 (519615d)"},"host":"rugvfnxozqzmpamnrgem.supabase.co:443","basePath":"/","schemes":["https"],"consumes":["application/json","application/vnd.pgrst.object+json;nulls=stripped","application/vnd.pgrst.object+json","text/csv"],"produces":["application/json","application/vnd.pgrst.object+json;nulls=stripped","application/vnd.pgrst.object+json","text/csv"],"paths":{"/":{"get":{"produces":["application/openapi+json","application/json"],"responses":{"200":{"description":"OK"}},"summary":"OpenAPI description (this document)","tags":["Introspection"]}},"/profiles":{"get":{"parameters":[{"$ref":"#/parameters/rowFilter.profiles.id"},{"$ref":"#/parameters/rowFilter.profiles.user_id"},{"$ref":"#/parameters/rowFilter.profiles.full_name"},{"$ref":"#/parameters/rowFilter.profiles.phone_number"},{"$ref":"#/parameters/rowFilter.profiles.created_at"},{"$ref":"#/parameters/rowFilter.profiles.updated_at"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/order"},{"$ref":"#/parameters/range"},{"$ref":"#/parameters/rangeUnit"},{"$ref":"#/parameters/offset"},{"$ref":"#/parameters/limit"},{"$ref":"#/parameters/preferCount"}],"responses":{"200":{"description":"OK","schema":{"items":{"$ref":"#/definitions/profiles"},"type":"array"}},"206":{"description":"Partial Content"}},"tags":["profiles"]},"post":{"parameters":[{"$ref":"#/parameters/body.profiles"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/preferPost"}],"responses":{"201":{"description":"Created"}},"tags":["profiles"]},"delete":{"parameters":[{"$ref":"#/parameters/rowFilter.profiles.id"},{"$ref":"#/parameters/rowFilter.profiles.user_id"},{"$ref":"#/parameters/rowFilter.profiles.full_name"},{"$ref":"#/parameters/rowFilter.profiles.phone_number"},{"$ref":"#/parameters/rowFilter.profiles.created_at"},{"$ref":"#/parameters/rowFilter.profiles.updated_at"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["profiles"]},"patch":{"parameters":[{"$ref":"#/parameters/rowFilter.profiles.id"},{"$ref":"#/parameters/rowFilter.profiles.user_id"},{"$ref":"#/parameters/rowFilter.profiles.full_name"},{"$ref":"#/parameters/rowFilter.profiles.phone_number"},{"$ref":"#/parameters/rowFilter.profiles.created_at"},{"$ref":"#/parameters/rowFilter.profiles.updated_at"},{"$ref":"#/parameters/body.profiles"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["profiles"]}},"/services":{"get":{"parameters":[{"$ref":"#/parameters/rowFilter.services.id"},{"$ref":"#/parameters/rowFilter.services.name"},{"$ref":"#/parameters/rowFilter.services.description"},{"$ref":"#/parameters/rowFilter.services.base_price"},{"$ref":"#/parameters/rowFilter.services.price_per_km"},{"$ref":"#/parameters/rowFilter.services.maneuver_charge"},{"$ref":"#/parameters/rowFilter.services.tow_truck_type"},{"$ref":"#/parameters/rowFilter.services.created_at"},{"$ref":"#/parameters/rowFilter.services.updated_at"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/order"},{"$ref":"#/parameters/range"},{"$ref":"#/parameters/rangeUnit"},{"$ref":"#/parameters/offset"},{"$ref":"#/parameters/limit"},{"$ref":"#/parameters/preferCount"}],"responses":{"200":{"description":"OK","schema":{"items":{"$ref":"#/definitions/services"},"type":"array"}},"206":{"description":"Partial Content"}},"tags":["services"]},"post":{"parameters":[{"$ref":"#/parameters/body.services"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/preferPost"}],"responses":{"201":{"description":"Created"}},"tags":["services"]},"delete":{"parameters":[{"$ref":"#/parameters/rowFilter.services.id"},{"$ref":"#/parameters/rowFilter.services.name"},{"$ref":"#/parameters/rowFilter.services.description"},{"$ref":"#/parameters/rowFilter.services.base_price"},{"$ref":"#/parameters/rowFilter.services.price_per_km"},{"$ref":"#/parameters/rowFilter.services.maneuver_charge"},{"$ref":"#/parameters/rowFilter.services.tow_truck_type"},{"$ref":"#/parameters/rowFilter.services.created_at"},{"$ref":"#/parameters/rowFilter.services.updated_at"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["services"]},"patch":{"parameters":[{"$ref":"#/parameters/rowFilter.services.id"},{"$ref":"#/parameters/rowFilter.services.name"},{"$ref":"#/parameters/rowFilter.services.description"},{"$ref":"#/parameters/rowFilter.services.base_price"},{"$ref":"#/parameters/rowFilter.services.price_per_km"},{"$ref":"#/parameters/rowFilter.services.maneuver_charge"},{"$ref":"#/parameters/rowFilter.services.tow_truck_type"},{"$ref":"#/parameters/rowFilter.services.created_at"},{"$ref":"#/parameters/rowFilter.services.updated_at"},{"$ref":"#/parameters/body.services"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["services"]}},"/bookings":{"get":{"parameters":[{"$ref":"#/parameters/rowFilter.bookings.id"},{"$ref":"#/parameters/rowFilter.bookings.user_id"},{"$ref":"#/parameters/rowFilter.bookings.service_id"},{"$ref":"#/parameters/rowFilter.bookings.status"},{"$ref":"#/parameters/rowFilter.bookings.payment_status"},{"$ref":"#/parameters/rowFilter.bookings.pickup_location"},{"$ref":"#/parameters/rowFilter.bookings.dropoff_location"},{"$ref":"#/parameters/rowFilter.bookings.vehicle_details"},{"$ref":"#/parameters/rowFilter.bookings.distance"},{"$ref":"#/parameters/rowFilter.bookings.total_cost"},{"$ref":"#/parameters/rowFilter.bookings.pickup_datetime"},{"$ref":"#/parameters/rowFilter.bookings.additional_details"},{"$ref":"#/parameters/rowFilter.bookings.created_at"},{"$ref":"#/parameters/rowFilter.bookings.updated_at"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/order"},{"$ref":"#/parameters/range"},{"$ref":"#/parameters/rangeUnit"},{"$ref":"#/parameters/offset"},{"$ref":"#/parameters/limit"},{"$ref":"#/parameters/preferCount"}],"responses":{"200":{"description":"OK","schema":{"items":{"$ref":"#/definitions/bookings"},"type":"array"}},"206":{"description":"Partial Content"}},"tags":["bookings"]},"post":{"parameters":[{"$ref":"#/parameters/body.bookings"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/preferPost"}],"responses":{"201":{"description":"Created"}},"tags":["bookings"]},"delete":{"parameters":[{"$ref":"#/parameters/rowFilter.bookings.id"},{"$ref":"#/parameters/rowFilter.bookings.user_id"},{"$ref":"#/parameters/rowFilter.bookings.service_id"},{"$ref":"#/parameters/rowFilter.bookings.status"},{"$ref":"#/parameters/rowFilter.bookings.payment_status"},{"$ref":"#/parameters/rowFilter.bookings.pickup_location"},{"$ref":"#/parameters/rowFilter.bookings.dropoff_location"},{"$ref":"#/parameters/rowFilter.bookings.vehicle_details"},{"$ref":"#/parameters/rowFilter.bookings.distance"},{"$ref":"#/parameters/rowFilter.bookings.total_cost"},{"$ref":"#/parameters/rowFilter.bookings.pickup_datetime"},{"$ref":"#/parameters/rowFilter.bookings.additional_details"},{"$ref":"#/parameters/rowFilter.bookings.created_at"},{"$ref":"#/parameters/rowFilter.bookings.updated_at"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["bookings"]},"patch":{"parameters":[{"$ref":"#/parameters/rowFilter.bookings.id"},{"$ref":"#/parameters/rowFilter.bookings.user_id"},{"$ref":"#/parameters/rowFilter.bookings.service_id"},{"$ref":"#/parameters/rowFilter.bookings.status"},{"$ref":"#/parameters/rowFilter.bookings.payment_status"},{"$ref":"#/parameters/rowFilter.bookings.pickup_location"},{"$ref":"#/parameters/rowFilter.bookings.dropoff_location"},{"$ref":"#/parameters/rowFilter.bookings.vehicle_details"},{"$ref":"#/parameters/rowFilter.bookings.distance"},{"$ref":"#/parameters/rowFilter.bookings.total_cost"},{"$ref":"#/parameters/rowFilter.bookings.pickup_datetime"},{"$ref":"#/parameters/rowFilter.bookings.additional_details"},{"$ref":"#/parameters/rowFilter.bookings.created_at"},{"$ref":"#/parameters/rowFilter.bookings.updated_at"},{"$ref":"#/parameters/body.bookings"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["bookings"]}},"/smtp_settings":{"get":{"parameters":[{"$ref":"#/parameters/rowFilter.smtp_settings.id"},{"$ref":"#/parameters/rowFilter.smtp_settings.user_id"},{"$ref":"#/parameters/rowFilter.smtp_settings.host"},{"$ref":"#/parameters/rowFilter.smtp_settings.port"},{"$ref":"#/parameters/rowFilter.smtp_settings.username"},{"$ref":"#/parameters/rowFilter.smtp_settings.password"},{"$ref":"#/parameters/rowFilter.smtp_settings.created_at"},{"$ref":"#/parameters/rowFilter.smtp_settings.updated_at"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/order"},{"$ref":"#/parameters/range"},{"$ref":"#/parameters/rangeUnit"},{"$ref":"#/parameters/offset"},{"$ref":"#/parameters/limit"},{"$ref":"#/parameters/preferCount"}],"responses":{"200":{"description":"OK","schema":{"items":{"$ref":"#/definitions/smtp_settings"},"type":"array"}},"206":{"description":"Partial Content"}},"tags":["smtp_settings"]},"post":{"parameters":[{"$ref":"#/parameters/body.smtp_settings"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/preferPost"}],"responses":{"201":{"description":"Created"}},"tags":["smtp_settings"]},"delete":{"parameters":[{"$ref":"#/parameters/rowFilter.smtp_settings.id"},{"$ref":"#/parameters/rowFilter.smtp_settings.user_id"},{"$ref":"#/parameters/rowFilter.smtp_settings.host"},{"$ref":"#/parameters/rowFilter.smtp_settings.port"},{"$ref":"#/parameters/rowFilter.smtp_settings.username"},{"$ref":"#/parameters/rowFilter.smtp_settings.password"},{"$ref":"#/parameters/rowFilter.smtp_settings.created_at"},{"$ref":"#/parameters/rowFilter.smtp_settings.updated_at"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["smtp_settings"]},"patch":{"parameters":[{"$ref":"#/parameters/rowFilter.smtp_settings.id"},{"$ref":"#/parameters/rowFilter.smtp_settings.user_id"},{"$ref":"#/parameters/rowFilter.smtp_settings.host"},{"$ref":"#/parameters/rowFilter.smtp_settings.port"},{"$ref":"#/parameters/rowFilter.smtp_settings.username"},{"$ref":"#/parameters/rowFilter.smtp_settings.password"},{"$ref":"#/parameters/rowFilter.smtp_settings.created_at"},{"$ref":"#/parameters/rowFilter.smtp_settings.updated_at"},{"$ref":"#/parameters/body.smtp_settings"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["smtp_settings"]}},"/users":{"get":{"parameters":[{"$ref":"#/parameters/rowFilter.users.id"},{"$ref":"#/parameters/rowFilter.users.email"},{"$ref":"#/parameters/rowFilter.users.encrypted_password"},{"$ref":"#/parameters/rowFilter.users.role"},{"$ref":"#/parameters/rowFilter.users.created_at"},{"$ref":"#/parameters/rowFilter.users.updated_at"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/order"},{"$ref":"#/parameters/range"},{"$ref":"#/parameters/rangeUnit"},{"$ref":"#/parameters/offset"},{"$ref":"#/parameters/limit"},{"$ref":"#/parameters/preferCount"}],"responses":{"200":{"description":"OK","schema":{"items":{"$ref":"#/definitions/users"},"type":"array"}},"206":{"description":"Partial Content"}},"tags":["users"]},"post":{"parameters":[{"$ref":"#/parameters/body.users"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/preferPost"}],"responses":{"201":{"description":"Created"}},"tags":["users"]},"delete":{"parameters":[{"$ref":"#/parameters/rowFilter.users.id"},{"$ref":"#/parameters/rowFilter.users.email"},{"$ref":"#/parameters/rowFilter.users.encrypted_password"},{"$ref":"#/parameters/rowFilter.users.role"},{"$ref":"#/parameters/rowFilter.users.created_at"},{"$ref":"#/parameters/rowFilter.users.updated_at"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["users"]},"patch":{"parameters":[{"$ref":"#/parameters/rowFilter.users.id"},{"$ref":"#/parameters/rowFilter.users.email"},{"$ref":"#/parameters/rowFilter.users.encrypted_password"},{"$ref":"#/parameters/rowFilter.users.role"},{"$ref":"#/parameters/rowFilter.users.created_at"},{"$ref":"#/parameters/rowFilter.users.updated_at"},{"$ref":"#/parameters/body.users"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["users"]}},"/password_failed_verification_attempts":{"get":{"parameters":[{"$ref":"#/parameters/rowFilter.password_failed_verification_attempts.user_id"},{"$ref":"#/parameters/rowFilter.password_failed_verification_attempts.last_failed_at"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/order"},{"$ref":"#/parameters/range"},{"$ref":"#/parameters/rangeUnit"},{"$ref":"#/parameters/offset"},{"$ref":"#/parameters/limit"},{"$ref":"#/parameters/preferCount"}],"responses":{"200":{"description":"OK","schema":{"items":{"$ref":"#/definitions/password_failed_verification_attempts"},"type":"array"}},"206":{"description":"Partial Content"}},"tags":["password_failed_verification_attempts"]},"post":{"parameters":[{"$ref":"#/parameters/body.password_failed_verification_attempts"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/preferPost"}],"responses":{"201":{"description":"Created"}},"tags":["password_failed_verification_attempts"]},"delete":{"parameters":[{"$ref":"#/parameters/rowFilter.password_failed_verification_attempts.user_id"},{"$ref":"#/parameters/rowFilter.password_failed_verification_attempts.last_failed_at"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["password_failed_verification_attempts"]},"patch":{"parameters":[{"$ref":"#/parameters/rowFilter.password_failed_verification_attempts.user_id"},{"$ref":"#/parameters/rowFilter.password_failed_verification_attempts.last_failed_at"},{"$ref":"#/parameters/body.password_failed_verification_attempts"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"tags":["password_failed_verification_attempts"]}},"/rpc/hook_password_verification_attempt":{"get":{"parameters":[{"format":"jsonb","in":"query","name":"event","required":true,"type":"string"}],"produces":["application/json","application/vnd.pgrst.object+json;nulls=stripped","application/vnd.pgrst.object+json"],"responses":{"200":{"description":"OK"}},"tags":["(rpc) hook_password_verification_attempt"]},"post":{"parameters":[{"in":"body","name":"args","required":true,"schema":{"properties":{"event":{"format":"jsonb"}},"required":["event"],"type":"object"}},{"$ref":"#/parameters/preferParams"}],"produces":["application/json","application/vnd.pgrst.object+json;nulls=stripped","application/vnd.pgrst.object+json"],"responses":{"200":{"description":"OK"}},"tags":["(rpc) hook_password_verification_attempt"]}},"/rpc/custom_access_token_hook":{"get":{"parameters":[{"format":"jsonb","in":"query","name":"event","required":true,"type":"string"}],"produces":["application/json","application/vnd.pgrst.object+json;nulls=stripped","application/vnd.pgrst.object+json"],"responses":{"200":{"description":"OK"}},"tags":["(rpc) custom_access_token_hook"]},"post":{"parameters":[{"in":"body","name":"args","required":true,"schema":{"properties":{"event":{"format":"jsonb"}},"required":["event"],"type":"object"}},{"$ref":"#/parameters/preferParams"}],"produces":["application/json","application/vnd.pgrst.object+json;nulls=stripped","application/vnd.pgrst.object+json"],"responses":{"200":{"description":"OK"}},"tags":["(rpc) custom_access_token_hook"]}},"/rpc/get_current_user_id":{"get":{"produces":["application/json","application/vnd.pgrst.object+json;nulls=stripped","application/vnd.pgrst.object+json"],"responses":{"200":{"description":"OK"}},"tags":["(rpc) get_current_user_id"]},"post":{"parameters":[{"in":"body","name":"args","required":true,"schema":{"type":"object"}},{"$ref":"#/parameters/preferParams"}],"produces":["application/json","application/vnd.pgrst.object+json;nulls=stripped","application/vnd.pgrst.object+json"],"responses":{"200":{"description":"OK"}},"tags":["(rpc) get_current_user_id"]}}},"definitions":{"profiles":{"required":["id","user_id","full_name","created_at","updated_at"],"properties":{"id":{"default":"extensions.uuid_generate_v4()","description":"Note:\nThis is a Primary Key.<pk/>","format":"uuid","type":"string"},"user_id":{"description":"Note:\nThis is a Foreign Key to `users.id`.<fk table='users' column='id'/>","format":"uuid","type":"string"},"full_name":{"format":"text","type":"string"},"phone_number":{"format":"text","type":"string"},"created_at":{"default":"now()","format":"timestamp with time zone","type":"string"},"updated_at":{"default":"now()","format":"timestamp with time zone","type":"string"}},"type":"object"},"services":{"required":["id","name","base_price","price_per_km","maneuver_charge","tow_truck_type","created_at","updated_at"],"properties":{"id":{"default":"gen_random_uuid()","description":"Note:\nThis is a Primary Key.<pk/>","format":"uuid","type":"string"},"name":{"format":"text","type":"string"},"description":{"format":"text","type":"string"},"base_price":{"format":"numeric","type":"number"},"price_per_km":{"format":"numeric","type":"number"},"maneuver_charge":{"format":"numeric","type":"number"},"tow_truck_type":{"enum":["flatbed","wheel_lift","integrated","heavy_duty"],"format":"public.tow_truck_type","type":"string"},"created_at":{"default":"now()","format":"timestamp with time zone","type":"string"},"updated_at":{"default":"now()","format":"timestamp with time zone","type":"string"}},"type":"object"},"bookings":{"required":["id","user_id","service_id","status","payment_status","pickup_location","dropoff_location","vehicle_details","distance","total_cost","pickup_datetime","created_at","updated_at"],"properties":{"id":{"default":"extensions.uuid_generate_v4()","description":"Note:\nThis is a Primary Key.<pk/>","format":"uuid","type":"string"},"user_id":{"description":"Note:\nThis is a Foreign Key to `users.id`.<fk table='users' column='id'/>","format":"uuid","type":"string"},"service_id":{"description":"Note:\nThis is a Foreign Key to `services.id`.<fk table='services' column='id'/>","format":"uuid","type":"string"},"status":{"default":"pending","enum":["pending","confirmed","in_progress","completed","cancelled"],"format":"public.booking_status","type":"string"},"payment_status":{"default":"pending","enum":["pending","paid","failed","refunded"],"format":"public.payment_status","type":"string"},"pickup_location":{"format":"text","type":"string"},"dropoff_location":{"format":"text","type":"string"},"vehicle_details":{"format":"jsonb"},"distance":{"format":"numeric","type":"number"},"total_cost":{"format":"numeric","type":"number"},"pickup_datetime":{"format":"timestamp with time zone","type":"string"},"additional_details":{"format":"text","type":"string"},"created_at":{"default":"now()","format":"timestamp with time zone","type":"string"},"updated_at":{"default":"now()","format":"timestamp with time zone","type":"string"}},"type":"object"},"smtp_settings":{"required":["id","user_id","host","port","username","password","created_at","updated_at"],"properties":{"id":{"default":"extensions.uuid_generate_v4()","description":"Note:\nThis is a Primary Key.<pk/>","format":"uuid","type":"string"},"user_id":{"description":"Note:\nThis is a Foreign Key to `users.id`.<fk table='users' column='id'/>","format":"uuid","type":"string"},"host":{"format":"text","type":"string"},"port":{"format":"integer","type":"integer"},"username":{"format":"text","type":"string"},"password":{"format":"text","type":"string"},"created_at":{"default":"now()","format":"timestamp with time zone","type":"string"},"updated_at":{"default":"now()","format":"timestamp with time zone","type":"string"}},"type":"object"},"users":{"required":["id","email","encrypted_password","role","created_at","updated_at"],"properties":{"id":{"default":"extensions.uuid_generate_v4()","description":"Note:\nThis is a Primary Key.<pk/>","format":"uuid","type":"string"},"email":{"format":"text","type":"string"},"encrypted_password":{"format":"text","type":"string"},"role":{"default":"user","enum":["user","admin","super_admin"],"format":"public.user_role","type":"string"},"created_at":{"default":"now()","format":"timestamp with time zone","type":"string"},"updated_at":{"default":"now()","format":"timestamp with time zone","type":"string"}},"type":"object"},"password_failed_verification_attempts":{"required":["user_id","last_failed_at"],"properties":{"user_id":{"description":"Note:\nThis is a Primary Key.<pk/>","format":"uuid","type":"string"},"last_failed_at":{"format":"timestamp with time zone","type":"string"}},"type":"object"}},"parameters":{"preferParams":{"name":"Prefer","description":"Preference","required":false,"enum":["params=single-object"],"in":"header","type":"string"},"preferReturn":{"name":"Prefer","description":"Preference","required":false,"enum":["return=representation","return=minimal","return=none"],"in":"header","type":"string"},"preferCount":{"name":"Prefer","description":"Preference","required":false,"enum":["count=none"],"in":"header","type":"string"},"preferPost":{"name":"Prefer","description":"Preference","required":false,"enum":["return=representation","return=minimal","return=none","resolution=ignore-duplicates","resolution=merge-duplicates"],"in":"header","type":"string"},"select":{"name":"select","description":"Filtering Columns","required":false,"in":"query","type":"string"},"on_conflict":{"name":"on_conflict","description":"On Conflict","required":false,"in":"query","type":"string"},"order":{"name":"order","description":"Ordering","required":false,"in":"query","type":"string"},"range":{"name":"Range","description":"Limiting and Pagination","required":false,"in":"header","type":"string"},"rangeUnit":{"name":"Range-Unit","description":"Limiting and Pagination","required":false,"default":"items","in":"header","type":"string"},"offset":{"name":"offset","description":"Limiting and Pagination","required":false,"in":"query","type":"string"},"limit":{"name":"limit","description":"Limiting and Pagination","required":false,"in":"query","type":"string"},"body.profiles":{"name":"profiles","description":"profiles","required":false,"in":"body","schema":{"$ref":"#/definitions/profiles"}},"rowFilter.profiles.id":{"name":"id","required":false,"in":"query","type":"string"},"rowFilter.profiles.user_id":{"name":"user_id","required":false,"in":"query","type":"string"},"rowFilter.profiles.full_name":{"name":"full_name","required":false,"in":"query","type":"string"},"rowFilter.profiles.phone_number":{"name":"phone_number","required":false,"in":"query","type":"string"},"rowFilter.profiles.created_at":{"name":"created_at","required":false,"in":"query","type":"string"},"rowFilter.profiles.updated_at":{"name":"updated_at","required":false,"in":"query","type":"string"},"body.services":{"name":"services","description":"services","required":false,"in":"body","schema":{"$ref":"#/definitions/services"}},"rowFilter.services.id":{"name":"id","required":false,"in":"query","type":"string"},"rowFilter.services.name":{"name":"name","required":false,"in":"query","type":"string"},"rowFilter.services.description":{"name":"description","required":false,"in":"query","type":"string"},"rowFilter.services.base_price":{"name":"base_price","required":false,"in":"query","type":"string"},"rowFilter.services.price_per_km":{"name":"price_per_km","required":false,"in":"query","type":"string"},"rowFilter.services.maneuver_charge":{"name":"maneuver_charge","required":false,"in":"query","type":"string"},"rowFilter.services.tow_truck_type":{"name":"tow_truck_type","required":false,"in":"query","type":"string"},"rowFilter.services.created_at":{"name":"created_at","required":false,"in":"query","type":"string"},"rowFilter.services.updated_at":{"name":"updated_at","required":false,"in":"query","type":"string"},"body.bookings":{"name":"bookings","description":"bookings","required":false,"in":"body","schema":{"$ref":"#/definitions/bookings"}},"rowFilter.bookings.id":{"name":"id","required":false,"in":"query","type":"string"},"rowFilter.bookings.user_id":{"name":"user_id","required":false,"in":"query","type":"string"},"rowFilter.bookings.service_id":{"name":"service_id","required":false,"in":"query","type":"string"},"rowFilter.bookings.status":{"name":"status","required":false,"in":"query","type":"string"},"rowFilter.bookings.payment_status":{"name":"payment_status","required":false,"in":"query","type":"string"},"rowFilter.bookings.pickup_location":{"name":"pickup_location","required":false,"in":"query","type":"string"},"rowFilter.bookings.dropoff_location":{"name":"dropoff_location","required":false,"in":"query","type":"string"},"rowFilter.bookings.vehicle_details":{"name":"vehicle_details","required":false,"in":"query","type":"string"},"rowFilter.bookings.distance":{"name":"distance","required":false,"in":"query","type":"string"},"rowFilter.bookings.total_cost":{"name":"total_cost","required":false,"in":"query","type":"string"},"rowFilter.bookings.pickup_datetime":{"name":"pickup_datetime","required":false,"in":"query","type":"string"},"rowFilter.bookings.additional_details":{"name":"additional_details","required":false,"in":"query","type":"string"},"rowFilter.bookings.created_at":{"name":"created_at","required":false,"in":"query","type":"string"},"rowFilter.bookings.updated_at":{"name":"updated_at","required":false,"in":"query","type":"string"},"body.smtp_settings":{"name":"smtp_settings","description":"smtp_settings","required":false,"in":"body","schema":{"$ref":"#/definitions/smtp_settings"}},"rowFilter.smtp_settings.id":{"name":"id","required":false,"in":"query","type":"string"},"rowFilter.smtp_settings.user_id":{"name":"user_id","required":false,"in":"query","type":"string"},"rowFilter.smtp_settings.host":{"name":"host","required":false,"in":"query","type":"string"},"rowFilter.smtp_settings.port":{"name":"port","required":false,"in":"query","type":"string"},"rowFilter.smtp_settings.username":{"name":"username","required":false,"in":"query","type":"string"},"rowFilter.smtp_settings.password":{"name":"password","required":false,"in":"query","type":"string"},"rowFilter.smtp_settings.created_at":{"name":"created_at","required":false,"in":"query","type":"string"},"rowFilter.smtp_settings.updated_at":{"name":"updated_at","required":false,"in":"query","type":"string"},"body.users":{"name":"users","description":"users","required":false,"in":"body","schema":{"$ref":"#/definitions/users"}},"rowFilter.users.id":{"name":"id","required":false,"in":"query","type":"string"},"rowFilter.users.email":{"name":"email","required":false,"in":"query","type":"string"},"rowFilter.users.encrypted_password":{"name":"encrypted_password","required":false,"in":"query","type":"string"},"rowFilter.users.role":{"name":"role","required":false,"in":"query","type":"string"},"rowFilter.users.created_at":{"name":"created_at","required":false,"in":"query","type":"string"},"rowFilter.users.updated_at":{"name":"updated_at","required":false,"in":"query","type":"string"},"body.password_failed_verification_attempts":{"name":"password_failed_verification_attempts","description":"password_failed_verification_attempts","required":false,"in":"body","schema":{"$ref":"#/definitions/password_failed_verification_attempts"}},"rowFilter.password_failed_verification_attempts.user_id":{"name":"user_id","required":false,"in":"query","type":"string"},"rowFilter.password_failed_verification_attempts.last_failed_at":{"name":"last_failed_at","required":false,"in":"query","type":"string"}},"externalDocs":{"description":"PostgREST Documentation","url":"https://postgrest.org/en/v12/references/api.html"}}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\integrations\supabase\supabase.js
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_PROJECT_URL;
const supabaseKey = import.meta.env.VITE_SUPABASE_API_KEY;

export const supabase = createClient(supabaseUrl, supabaseKey);


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\integrations\supabase\hooks\bookings.js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '../supabase';

const fromSupabase = async (query) => {
    const { data, error } = await query;
    if (error) throw new Error(error.message);
    return data;
};

/*
### bookings

| name               | type                     | format | required |
|--------------------|--------------------------|--------|----------|
| id                 | uuid                     | string | true     |
| user_id            | uuid                     | string | true     |
| service_id         | uuid                     | string | true     |
| status             | public.booking_status    | string | true     |
| payment_status     | public.payment_status    | string | true     |
| pickup_location    | text                     | string | true     |
| dropoff_location   | text                     | string | true     |
| vehicle_details    | jsonb                    | object | true     |
| distance           | numeric                  | number | true     |
| total_cost         | numeric                  | number | true     |
| pickup_datetime    | timestamp with time zone | string | true     |
| additional_details | text                     | string | false    |
| created_at         | timestamp with time zone | string | true     |
| updated_at         | timestamp with time zone | string | true     |

Foreign Key Relationships:
- user_id references users.id
- service_id references services.id
*/

export const useBooking = (id) => useQuery({
    queryKey: ['bookings', id],
    queryFn: () => fromSupabase(supabase.from('bookings').select('*').eq('id', id).single()),
});

export const useBookings = () => useQuery({
    queryKey: ['bookings'],
    queryFn: () => fromSupabase(supabase.from('bookings').select('*')),
});

export const useAddBooking = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (newBooking) => fromSupabase(supabase.from('bookings').insert([newBooking])),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['bookings'] });
        },
    });
};

export const useUpdateBooking = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: ({ id, ...updateData }) => fromSupabase(supabase.from('bookings').update(updateData).eq('id', id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['bookings'] });
        },
    });
};

export const useDeleteBooking = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (id) => fromSupabase(supabase.from('bookings').delete().eq('id', id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['bookings'] });
        },
    });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\integrations\supabase\hooks\password_failed_verification_attempts.js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '../supabase';

const fromSupabase = async (query) => {
    const { data, error } = await query;
    if (error) throw new Error(error.message);
    return data;
};

/*
### password_failed_verification_attempts

| name           | type                     | format | required |
|----------------|--------------------------|--------|----------|
| user_id        | uuid                     | string | true     |
| last_failed_at | timestamp with time zone | string | true     |

Note: user_id is the Primary Key.
*/

export const usePasswordFailedVerificationAttempt = (userId) => useQuery({
    queryKey: ['password_failed_verification_attempts', userId],
    queryFn: () => fromSupabase(supabase.from('password_failed_verification_attempts').select('*').eq('user_id', userId).single()),
});

export const usePasswordFailedVerificationAttempts = () => useQuery({
    queryKey: ['password_failed_verification_attempts'],
    queryFn: () => fromSupabase(supabase.from('password_failed_verification_attempts').select('*')),
});

export const useAddPasswordFailedVerificationAttempt = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (newAttempt) => fromSupabase(supabase.from('password_failed_verification_attempts').insert([newAttempt])),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['password_failed_verification_attempts'] });
        },
    });
};

export const useUpdatePasswordFailedVerificationAttempt = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: ({ user_id, ...updateData }) => fromSupabase(supabase.from('password_failed_verification_attempts').update(updateData).eq('user_id', user_id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['password_failed_verification_attempts'] });
        },
    });
};

export const useDeletePasswordFailedVerificationAttempt = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (user_id) => fromSupabase(supabase.from('password_failed_verification_attempts').delete().eq('user_id', user_id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['password_failed_verification_attempts'] });
        },
    });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\integrations\supabase\hooks\profiles.js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '../supabase';

const fromSupabase = async (query) => {
    const { data, error } = await query;
    if (error) throw new Error(error.message);
    return data;
};

/*
### profiles

| name         | type                     | format | required |
|--------------|--------------------------|--------|----------|
| id           | uuid                     | string | true     |
| user_id      | uuid                     | string | true     |
| full_name    | text                     | string | true     |
| phone_number | text                     | string | false    |
| created_at   | timestamp with time zone | string | true     |

Foreign Key Relationships:
- user_id references users.id
*/

export const useProfile = (id) => useQuery({
    queryKey: ['profiles', id],
    queryFn: () => fromSupabase(supabase.from('profiles').select('*').eq('id', id).single()),
});

export const useProfiles = () => useQuery({
    queryKey: ['profiles'],
    queryFn: () => fromSupabase(supabase.from('profiles').select('*')),
});

export const useAddProfile = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (newProfile) => fromSupabase(supabase.from('profiles').insert([newProfile])),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['profiles'] });
        },
    });
};

export const useUpdateProfile = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: ({ id, ...updateData }) => fromSupabase(supabase.from('profiles').update(updateData).eq('id', id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['profiles'] });
        },
    });
};

export const useDeleteProfile = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (id) => fromSupabase(supabase.from('profiles').delete().eq('id', id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['profiles'] });
        },
    });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\integrations\supabase\hooks\services.js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '../supabase';

const fromSupabase = async (query) => {
    const { data, error } = await query;
    if (error) throw new Error(error.message);
    return data;
};

/*
### services

| name            | type                     | format | required |
|-----------------|--------------------------|--------|----------|
| id              | uuid                     | string | true     |
| name            | text                     | string | true     |
| description     | text                     | string | false    |
| base_price      | numeric                  | number | true     |
| price_per_km    | numeric                  | number | true     |
| maneuver_charge | numeric                  | number | true     |
| tow_truck_type  | public.tow_truck_type    | string | true     |
| created_at      | timestamp with time zone | string | true     |
| updated_at      | timestamp with time zone | string | true     |
*/

export const useService = (id) => useQuery({
    queryKey: ['services', id],
    queryFn: () => fromSupabase(supabase.from('services').select('*').eq('id', id).single()),
});

export const useServices = () => useQuery({
    queryKey: ['services'],
    queryFn: () => fromSupabase(supabase.from('services').select('*')),
});

export const useAddService = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (newService) => fromSupabase(supabase.from('services').insert([newService])),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['services'] });
        },
    });
};

export const useUpdateService = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: ({ id, ...updateData }) => fromSupabase(supabase.from('services').update(updateData).eq('id', id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['services'] });
        },
    });
};

export const useDeleteService = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (id) => fromSupabase(supabase.from('services').delete().eq('id', id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['services'] });
        },
    });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\integrations\supabase\hooks\smtp_settings.js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '../supabase';

const fromSupabase = async (query) => {
    const { data, error } = await query;
    if (error) throw new Error(error.message);
    return data;
};

/*
### smtp_settings

| name           | type                     | format  | required |
|----------------|--------------------------|---------|----------|
| id             | uuid                     | string  | true     |
| user_id        | uuid                     | string  | false    |
| is_custom_smtp | boolean                  | boolean | true     |
| smtp_host      | text                     | string  | false    |
| smtp_port      | integer                  | number  | false    |
| smtp_user      | text                     | string  | false    |
| smtp_password  | text                     | string  | false    |
| from_email     | text                     | string  | false    |
| from_name      | text                     | string  | false    |
| created_at     | timestamp with time zone | string  | true     |
| updated_at     | timestamp with time zone | string  | true     |

Foreign Key Relationships:
- user_id references users.id
*/

export const useSmtpSetting = (id) => useQuery({
    queryKey: ['smtp_settings', id],
    queryFn: () => fromSupabase(supabase.from('smtp_settings').select('*').eq('id', id).single()),
});

export const useSmtpSettings = () => useQuery({
    queryKey: ['smtp_settings'],
    queryFn: () => fromSupabase(supabase.from('smtp_settings').select('*')),
});

export const useAddSmtpSetting = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (newSmtpSetting) => fromSupabase(supabase.from('smtp_settings').insert([newSmtpSetting])),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['smtp_settings'] });
        },
    });
};

export const useUpdateSmtpSetting = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: ({ id, ...updateData }) => fromSupabase(supabase.from('smtp_settings').update(updateData).eq('id', id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['smtp_settings'] });
        },
    });
};

export const useDeleteSmtpSetting = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (id) => fromSupabase(supabase.from('smtp_settings').delete().eq('id', id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['smtp_settings'] });
        },
    });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\integrations\supabase\hooks\users.js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '../supabase';

const fromSupabase = async (query) => {
    const { data, error } = await query;
    if (error) throw new Error(error.message);
    return data;
};

/*
### users

| name               | type                     | format | required |
|--------------------|--------------------------|--------|----------|
| id                 | uuid                     | string | true     |
| email              | text                     | string | true     |
| encrypted_password | text                     | string | true     |
| role               | public.user_role         | string | true     |
| created_at         | timestamp with time zone | string | true     |
| updated_at         | timestamp with time zone | string | true     |
*/

export const useUser = (id) => useQuery({
    queryKey: ['users', id],
    queryFn: () => fromSupabase(supabase.from('users').select('*').eq('id', id).single()),
});

export const useUsers = () => useQuery({
    queryKey: ['users'],
    queryFn: () => fromSupabase(supabase.from('users').select('*')),
});

export const useAddUser = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (newUser) => fromSupabase(supabase.from('users').insert([newUser])),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['users'] });
        },
    });
};

export const useUpdateUser = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: ({ id, ...updateData }) => fromSupabase(supabase.from('users').update(updateData).eq('id', id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['users'] });
        },
    });
};

export const useDeleteUser = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: (id) => fromSupabase(supabase.from('users').delete().eq('id', id)),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['users'] });
        },
    });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\server\db.js
import { supabase } from '../config/supabaseClient';

export const getBookings = async () => {
  const { data, error, count } = await supabase
    .from('bookings')
    .select('*', { count: 'exact' });

  if (error) throw error;
  return { data, count };
};

export const saveDraftBooking = async (draftData) => {
  const { data, error } = await supabase
    .from('draft_bookings')
    .insert(draftData)
    .select();

  if (error) throw error;
  return data[0];
};

export const createBooking = async (bookingData) => {
  const { data, error } = await supabase
    .from('bookings')
    .insert({
      ...bookingData,
      additional_details: bookingData.additionalDetails, // Changed from additionalDetails to additional_details
    })
    .select();

  if (error) throw error;
  return data[0];
};

export const updateBooking = async (id, updateData) => {
  const { data, error } = await supabase
    .from('bookings')
    .update({
      ...updateData,
      additional_details: updateData.additionalDetails, // Changed from additionalDetails to additional_details
    })
    .eq('id', id)
    .select();

  if (error) throw error;
  return data[0];
};

export const deleteBooking = async (id) => {
  const { error } = await supabase
    .from('bookings')
    .delete()
    .eq('id', id);

  if (error) throw error;
  return true;
};

export const getPaidServicesWaiting = async () => {
  const { data, error } = await supabase
    .from('bookings')
    .select('*')
    .eq('payment_status', 'paid')
    .eq('status', 'pending')
    .order('created_at', { ascending: false });

  if (error) throw error;
  return data;
};

export const updateServiceStatus = async (id, newStatus) => {
  const { data, error } = await supabase
    .from('bookings')
    .update({ status: newStatus })
    .eq('id', id)
    .select();

  if (error) throw error;
  return data[0];
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\server\server.js
const express = require('express');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const config = require('./config/config');
const stripe = require('stripe')(config.stripeSecretKey);
const bookingRoutes = require('./routes/bookingRoutes');
const adminRoutes = require('./routes/adminRoutes');
const { errorHandler } = require('./middleware/errorHandler');
const { login, createAccount, getCurrentUser } = require('./db');

const app = express();

app.use(cors());
app.use(express.json());

// Rate limiting middleware
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Limit each IP to 5 requests per windowMs
  message: 'Too many authentication attempts, please try again later.',
});

app.use('/api/bookings', bookingRoutes);
app.use('/api/admin', adminRoutes);

app.post('/api/process-payment', async (req, res) => {
  const { paymentMethodId, amount } = req.body;

  try {
    const paymentIntent = await stripe.paymentIntents.create({
      amount,
      currency: 'usd',
      payment_method: paymentMethodId,
      confirm: true,
    });

    res.json({ success: true, paymentIntentId: paymentIntent.id });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

app.post('/api/login', authLimiter, async (req, res) => {
  try {
    const { email, password } = req.body;
    const result = await login(email, password);
    res.json(result);
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

app.post('/api/signup', authLimiter, async (req, res) => {
  try {
    const { email, password, userData } = req.body;
    const result = await createAccount(email, password, userData);
    res.json(result);
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

app.get('/api/current-user', async (req, res) => {
  try {
    const user = await getCurrentUser();
    if (user) {
      res.json(user);
    } else {
      res.status(401).json({ success: false, error: 'Not authenticated' });
    }
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

app.use(errorHandler);

const PORT = config.port || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

module.exports = app; // Export for testing purposes


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\server\config\config.js
const config = {
  port: import.meta.env.PORT || 5000,
  supabaseUrl: import.meta.env.VITE_SUPABASE_PROJECT_URL,
  supabaseKey: import.meta.env.VITE_SUPABASE_API_KEY,
  stripeSecretKey: import.meta.env.STRIPE_SECRET_KEY,
  tollguruApiKey: import.meta.env.VITE_TOLLGURU_API_KEY,
  nodeEnv: import.meta.env.NODE_ENV || 'development',
  jwtSecret: import.meta.env.JWT_SECRET,
};

export default config;


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\server\controllers\adminController.js
const supabase = require('../config/database');

exports.createAdmin = async (req, res, next) => {
  try {
    const { data, error } = await supabase
      .from('users')
      .insert({ ...req.body, is_admin: true });

    if (error) throw error;

    res.status(201).json({ success: true, data: data[0] });
  } catch (error) {
    next(error);
  }
};

exports.getPaidServices = async (req, res, next) => {
  try {
    const { data, error } = await supabase
      .from('services_logs')
      .select('*')
      .eq('status', 'paid')
      .order('created_at', { ascending: false });

    if (error) throw error;

    res.status(200).json({ success: true, data });
  } catch (error) {
    next(error);
  }
};

exports.updateService = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    const { data, error } = await supabase
      .from('services_logs')
      .update({ status })
      .eq('id', id);

    if (error) throw error;

    res.status(200).json({ success: true, data: data[0] });
  } catch (error) {
    next(error);
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\server\controllers\bookingController.js
const supabase = require('../config/database');
const { sendAdminNotification } = require('../../utils/adminNotification');
const { logger } = require('../middleware/errorHandler');
const { body, validationResult } = require('express-validator');

const addressValidation = (fieldName) => 
  body(fieldName)
    .notEmpty().withMessage(`${fieldName} is required`)
    .isLength({ min: 5 }).withMessage(`${fieldName} must be at least 5 characters`);

exports.validateBookingInput = [
  body('userName').notEmpty().withMessage('User name is required').isLength({ min: 2 }).withMessage('Name must be at least 2 characters'),
  body('phoneNumber').matches(/^\d{10}$/).withMessage('Phone number must be 10 digits'),
  body('serviceType').notEmpty().withMessage('Service type is required'),
  addressValidation('pickupAddress'),
  addressValidation('dropOffAddress'),
  body('vehicleBrand').notEmpty().withMessage('Vehicle brand is required'),
  body('vehicleModel').notEmpty().withMessage('Vehicle model is required'),
  body('vehicleColor').notEmpty().withMessage('Vehicle color is required'),
  body('licensePlate').notEmpty().withMessage('License plate is required').isLength({ min: 2 }).withMessage('License plate must be at least 2 characters'),
  body('pickupDateTime').isISO8601().toDate().withMessage('Invalid pickup date and time'),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    next();
  },
];

exports.createBooking = async (req, res, next) => {
  try {
    const bookingData = {
      user_id: req.body.userId,
      service_id: req.body.serviceId,
      status: 'pending',
      total_cost: req.body.totalCost,
      payment_status: 'pending',
      pickup_location: req.body.pickupAddress,
      dropoff_location: req.body.dropOffAddress,
      vehicle_brand: req.body.vehicleBrand,
      vehicle_model: req.body.vehicleModel,
      vehicle_color: req.body.vehicleColor,
      license_plate: req.body.licensePlate,
      vehicle_size: req.body.vehicleSize,
      in_neutral: req.body.inNeutral,
      engine_starts: req.body.engineStarts,
      wheels_turn: req.body.wheelsTurn,
      vehicle_position: req.body.vehiclePosition,
      requires_maneuver: req.body.requiresManeuver,
      distance: req.body.distance,
      pickup_datetime: req.body.pickupDateTime,
      additional_details: req.body.additionalDetails
    };

    const { data: createdBooking, error: bookingError } = await supabase
      .from('bookings')
      .insert(bookingData)
      .select();
    
    if (bookingError) throw bookingError;

    logger.info(`New booking created: ${JSON.stringify(createdBooking)}`);
    
    try {
      await sendAdminNotification(createdBooking[0], createdBooking[0].total_cost);
    } catch (notificationError) {
      logger.error(`Failed to send admin notification: ${notificationError.message}`);
      // Continue execution even if notification fails
    }

    res.status(201).json({
      success: true,
      message: 'Booking created successfully',
      booking: createdBooking[0]
    });
  } catch (error) {
    logger.error(`Error creating booking: ${error.message}`);
    next(error);
  }
};

exports.getAllBookings = async (req, res, next) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const startIndex = (page - 1) * limit;

    const { data, error, count } = await supabase
      .from('services_logs')
      .select('*, profiles(full_name), services(service_name)', { count: 'exact' })
      .range(startIndex, startIndex + limit - 1);
    
    if (error) throw error;

    res.status(200).json({
      success: true,
      count,
      data,
      totalPages: Math.ceil(count / limit),
      currentPage: page
    });
  } catch (error) {
    logger.error(`Error fetching bookings: ${error.message}`);
    next(error);
  }
};

exports.getBookingById = async (req, res, next) => {
  try {
    const { data, error } = await supabase
      .from('services_logs')
      .select('*, profiles(full_name), services(service_name)')
      .eq('id', req.params.id)
      .single();
    
    if (error) throw error;
    if (!data) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }

    res.status(200).json({
      success: true,
      data
    });
  } catch (error) {
    logger.error(`Error fetching booking by ID: ${error.message}`);
    next(error);
  }
};

exports.updateBooking = async (req, res, next) => {
  try {
    const { data, error } = await supabase
      .from('services_logs')
      .update(req.body)
      .eq('id', req.params.id);
    
    if (error) throw error;

    res.status(200).json({
      success: true,
      message: 'Booking updated successfully',
      data: data[0]
    });
  } catch (error) {
    logger.error(`Error updating booking: ${error.message}`);
    next(error);
  }
};

exports.deleteBooking = async (req, res, next) => {
  try {
    const { error } = await supabase
      .from('services_logs')
      .delete()
      .eq('id', req.params.id);
    
    if (error) throw error;

    res.status(200).json({
      success: true,
      message: 'Booking deleted successfully'
    });
  } catch (error) {
    logger.error(`Error deleting booking: ${error.message}`);
    next(error);
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\server\middleware\errorHandler.js
// Simple logger function compatible with both browser and Node.js
const logger = {
  error: (...args) => console.error(...args),
  warn: (...args) => console.warn(...args),
  info: (...args) => console.info(...args),
  debug: (...args) => console.debug(...args),
};

const errorHandler = (err, req, res, next) => {
  logger.error(`${err.status || 500} - ${err.message} - ${req.originalUrl} - ${req.method} - ${req.ip}`);

  res.status(err.status || 500).json({
    error: {
      message: err.message || 'Internal Server Error',
    },
  });
};

module.exports = { errorHandler, logger };


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\server\middleware\inputValidation.js
const { body, validationResult } = require('express-validator');

const addressValidation = (fieldName) => 
  body(fieldName)
    .notEmpty().withMessage(`${fieldName} is required`)
    .isLength({ min: 5 }).withMessage(`${fieldName} must be at least 5 characters`);

const validateBookingInput = [
  body('userName').notEmpty().withMessage('User name is required').isLength({ min: 2 }).withMessage('Name must be at least 2 characters'),
  body('phoneNumber').matches(/^\d{10}$/).withMessage('Phone number must be 10 digits'),
  body('serviceType').notEmpty().withMessage('Service type is required'),
  addressValidation('pickupAddress'),
  addressValidation('dropOffAddress'),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    next();
  },
];

module.exports = { validateBookingInput };


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\server\routes\adminRoutes.js
const express = require('express');
const router = express.Router();
const adminController = require('../controllers/adminController');

router.post('/create', adminController.createAdmin);
router.get('/services', adminController.getPaidServices);
router.put('/services/:id', adminController.updateService);

module.exports = router;


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\server\routes\bookingRoutes.js
const express = require('express');
const router = express.Router();
const bookingController = require('../controllers/bookingController');
const { validateBookingInput } = require('../middleware/inputValidation');

router.post('/', validateBookingInput, bookingController.createBooking);
router.get('/', bookingController.getAllBookings);
router.get('/:id', bookingController.getBookingById);
router.put('/:id', validateBookingInput, bookingController.updateBooking);
router.delete('/:id', bookingController.deleteBooking);

module.exports = router;


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\towingRequest\towingRequest.domain.facade.ts
import { Injectable } from '@nestjs/common';
import { TowingRequest } from './towingRequest.entity';

@Injectable()
export class TowingRequestDomainFacade {
  private towingRequests: TowingRequest[] = [];

  public findAll(): TowingRequest[] {
    return this.towingRequests;
  }

  public createOne(createDto: TowingRequest): TowingRequest {
    const newRequest = { ...createDto, id: Date.now().toString() };
    this.towingRequests.push(newRequest);
    return newRequest;
  }

  public findById(id: string): TowingRequest | undefined {
    return this.towingRequests.find(request => request.id === id);
  }

  public updateOne(id: string, updateDto: Partial<TowingRequest>): TowingRequest | undefined {
    const requestIndex = this.towingRequests.findIndex(request => request.id === id);
    if (requestIndex > -1) {
      this.towingRequests[requestIndex] = { ...this.towingRequests[requestIndex], ...updateDto };
      return this.towingRequests[requestIndex];
    }
    return undefined;
  }

  public deleteOne(id: string): boolean {
    const requestIndex = this.towingRequests.findIndex(request => request.id === id);
    if (requestIndex > -1) {
      this.towingRequests.splice(requestIndex, 1);
      return true;
    }
    return false;
  }

  public findByUserId(userId: string): TowingRequest[] {
    return this.towingRequests.filter(request => request.userId === userId);
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\towingRequest\towingRequest.domain.module.ts
import { Module } from '@nestjs/common';
import { TowingRequestDomainFacade } from './towingRequest.domain.facade';

@Module({
  providers: [TowingRequestDomainFacade],
  exports: [TowingRequestDomainFacade],
})
export class TowingRequestDomainModule {}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\towingRequest\towingRequest.entity.ts
export class TowingRequest {
  id: string;
  userId: string;
  pickupLocation: string;
  destinationLocation: string;
  additionalInfo?: string;
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\towingRequest\application\towingRequest.application.event.ts
export namespace TowingRequestApplicationEvent {
  export class TowingRequestCreated {
    static readonly key = 'towingRequest.created';
    constructor(public readonly id: string, public readonly userId: string) {}
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\towingRequest\application\towingRequest.application.module.ts
import { Module } from '@nestjs/common';
import { AuthenticationDomainModule } from '../authentication/authentication.domain.module';
import { TowingRequestDomainModule } from '../towing-request/towingRequest.domain.module';
import { UserDomainModule } from '../user/user.domain.module';

import { EventService } from '../event/event.service';
import { TowingRequestDomainFacade } from '../towingRequest/towingRequest.domain.facade';
import { AuthenticationDomainFacade } from '../authentication/authentication.domain.facade';
import { NewService } from '../new/new.service';

@Module({
  imports: [
    AuthenticationDomainModule,
    TowingRequestDomainModule,
    UserDomainModule,
  ],
  
  providers: [
    EventService,
    TowingRequestDomainFacade,
    {
      provide: 'AuthenticationDomainFacade',
      useClass: AuthenticationDomainFacade,
    },
    NewService,
  ],
})
export class TowingRequestApplicationModule {}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\towingRequest\application\towingRequest.controller.ts
import { Controller, Get, Post, Patch, Delete, Body, Param } from '@nestjs/common';
import { EventService } from '../event/event.service';
import { TowingRequestDomainFacade } from '../towingRequest/towingRequest.domain.facade';
import { AuthenticationDomainFacade } from '../authentication/authentication.domain.facade';
import { TowingRequestCreateDto, TowingRequestUpdateDto } from './towingRequest.dto';
import { TowingRequestApplicationEvent } from './towingRequest.application.event';
import { supabaseUrl, supabaseKey } from '../../config/supabase.config';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(supabaseUrl, supabaseKey);

@Controller('/v1/towingRequests')
export class TowingRequestController {
  constructor(
    private readonly eventService: EventService,
    private readonly towingRequestDomainFacade: TowingRequestDomainFacade,
    private readonly authenticationDomainFacade: AuthenticationDomainFacade,
  ) {}

  @Get()
  async findMany() {
    return this.towingRequestDomainFacade.findMany();
  }

  @Post()
  async create(@Body() createDto: TowingRequestCreateDto) {
    const towingRequest = await this.towingRequestDomainFacade.create(createDto);
    this.eventService.emit(new TowingRequestApplicationEvent.TowingRequestCreated(towingRequest.id, towingRequest.userId));
    return towingRequest;
  }

  @Post('/create')
  async createTowingRequest(@Body() createDto: TowingRequestCreateDto) {
    const { data, error } = await supabase
      .from('TOW')
      .insert([createDto]);

    if (error) {
      throw new Error(error.message);
    }

    return data;
  }

  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.towingRequestDomainFacade.findOne(id);
  }

  @Patch(':id')
  async update(@Param('id') id: string, @Body() updateDto: TowingRequestUpdateDto) {
    return this.towingRequestDomainFacade.update(id, updateDto);
  }

  @Delete(':id')
  async delete(@Param('id') id: string) {
    return this.towingRequestDomainFacade.delete(id);
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\towingRequest\application\towingRequest.dto.ts
import { IsString, IsNotEmpty, IsOptional, Matches } from 'class-validator';

export class TowingRequestCreateDto {
  @IsString()
  @IsNotEmpty()
  @Matches(/^[a-zA-Z0-9\s,'-]*$/, {
    message: 'Pickup location must be a valid address',
  })
  pickupLocation: string;

  @IsString()
  @IsNotEmpty()
  @Matches(/^[a-zA-Z0-9\s,'-]*$/, {
    message: 'Destination location must be a valid address',
  })
  destinationLocation: string;

  @IsString()
  @IsOptional()
  additionalInfo?: string;
}

export class TowingRequestUpdateDto {
  @IsString()
  @IsOptional()
  @Matches(/^[a-zA-Z0-9\s,'-]*$/, {
    message: 'Pickup location must be a valid address',
  })
  pickupLocation?: string;

  @IsString()
  @IsOptional()
  @Matches(/^[a-zA-Z0-9\s,'-]*$/, {
    message: 'Destination location must be a valid address',
  })
  destinationLocation?: string;

  @IsString()
  @IsOptional()
  additionalInfo?: string;
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\towingRequest\application\towingRequestByUser.controller.ts
import { Controller, Get, Param } from '@nestjs/common';
import { TowingRequestDomainFacade } from '../towingRequest/towingRequest.domain.facade';

@Controller('/v1/users/:userId/towingRequests')
export class TowingRequestByUserController {
  constructor(private readonly towingRequestDomainFacade: TowingRequestDomainFacade) {}

  @Get()
  async findByUser(@Param('userId') userId: string) {
    return this.towingRequestDomainFacade.findByUser(userId);
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\types\booking.js
export interface Booking {
  id: string;
  user_id: string;
  service_id: string;
  status: 'pending' | 'confirmed' | 'completed' | 'cancelled';
  payment_status: 'pending' | 'paid' | 'failed';
  pickup_location: string;
  dropoff_location: string;
  vehicle_details: {
    brand: string;
    model: string;
    color: string;
    license_plate: string;
    size: 'small' | 'medium' | 'large';
  };
  distance: number;
  total_cost: number;
  pickup_datetime: string;
  additional_details?: string;
  created_at: string;
  updated_at: string;
}

export interface User {
  id: string;
  email: string;
  role: 'user' | 'admin' | 'super_admin';
}

export interface Service {
  id: string;
  name: string;
  description?: string;
  base_price: number;
  price_per_km: number;
  maneuver_charge: number;
  tow_truck_type: 'A' | 'C' | 'D';
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\types\index.ts
// Global type declarations
declare global {
  interface ImportMetaEnv {
    readonly VITE_SUPABASE_PROJECT_URL: string;
    readonly VITE_SUPABASE_API_KEY: string;
    readonly VITE_GOOGLE_MAPS_API_KEY: string;
    readonly VITE_STRIPE_PUBLISHABLE_KEY: string;
    readonly VITE_GOOGLE_MAPS_ID: string;
    readonly VITE_TOLLGURU_API_KEY: string;
  }

  interface ImportMeta {
    readonly env: ImportMetaEnv;
  }
}

// Export empty object to make this a module
export {};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\user\user.domain.module.ts
import { Module } from '@nestjs/common';

@Module({})
export class UserDomainModule {}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\accessibility.js
import React from 'react';
import ReactDOM from 'react-dom';
import axe from '@axe-core/react';

export const runAccessibilityChecks = () => {
  if (process.env.NODE_ENV !== 'production') {
    axe(React, ReactDOM, 1000);
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\adminNotification.js
import { supabase } from '../config/supabaseClient';

export const sendAdminNotification = async (bookingData, totalCost) => {
  try {
    const notificationData = {
      service_type: bookingData.serviceType,
      user_name: bookingData.userName,
      phone_number: bookingData.phoneNumber,
      vehicle_make: bookingData.vehicleBrand,
      vehicle_model: bookingData.vehicleModel,
      vehicle_size: bookingData.vehicleSize,
      total_cost: totalCost,
      status: 'paid',
      created_at: new Date().toISOString(),
    };

    const { data, error } = await supabase
      .from('admin_notifications')
      .insert([notificationData]);

    if (error) throw error;
    console.log('Admin notification sent successfully:', data);

    // Send a real-time notification to admin users
    await supabase
      .from('admin_notifications')
      .on('INSERT', (payload) => {
        console.log('New admin notification:', payload.new);
        // Here you can implement additional logic to notify admins in real-time
        // For example, you could use a websocket or push notification service
      })
      .subscribe();

    return data;
  } catch (error) {
    console.error('Error sending admin notification:', error);
    throw new Error('Failed to send admin notification');
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\adminUtils.js
import { getUserRole } from '../config/supabase.config';

export const isAdmin = async (userId) => {
  if (!userId) {
    console.warn('No user ID provided for admin check');
    return false;
  }
  try {
    const role = await getUserRole(userId);
    return role === 'admin' || role === 'super_admin';
  } catch (error) {
    console.error('Error checking admin status:', error);
    return false;
  }
};

export const isSuperAdmin = async (userId) => {
  if (!userId) {
    console.warn('No user ID provided for super admin check');
    return false;
  }
  try {
    const role = await getUserRole(userId);
    return role === 'super_admin';
  } catch (error) {
    console.error('Error checking super admin status:', error);
    return false;
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\api.js
import { supabase } from '../config/supabase.config';

export const saveSMTPSettings = async (settings) => {
  const { data, error } = await supabase
    .from('smtp_settings')
    .upsert([settings], { onConflict: 'user_id' });

  if (error) throw error;
  return data;
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\backup.js
import { supabase } from '../config/supabase.config';

export const backupDatabase = async () => {
  try {
    // This is a simplified example. In a real-world scenario, you'd use a more robust backup solution.
    const { data, error } = await supabase.rpc('backup_database');
    if (error) throw error;
    console.log('Database backup completed successfully:', data);
    return data;
  } catch (error) {
    console.error('Error during database backup:', error);
    throw error;
  }
};

export const testRecovery = async (backupId) => {
  try {
    // This is a simplified example. In a real-world scenario, you'd have a separate test environment.
    const { data, error } = await supabase.rpc('test_recovery', { backup_id: backupId });
    if (error) throw error;
    console.log('Recovery test completed successfully:', data);
    return data;
  } catch (error) {
    console.error('Error during recovery test:', error);
    throw error;
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\diagnostics.js
import { supabase } from '../config/supabase.config';

export const runDiagnostics = async () => {
  const diagnosticResults = {
    databaseConnection: false,
    tables: {
      users: { exists: false, count: 0 },
      profiles: { exists: false, count: 0 },
      services: { exists: false, count: 0 },
      bookings: { exists: false, count: 0 },
    },
    relationships: {
      bookings_users: false,
      bookings_services: false,
      profiles_users: false,
    },
    paymentIntegration: false
  };

  try {
    // Test database connection
    const { data, error } = await supabase.from('users').select('count', { count: 'exact' });
    diagnosticResults.databaseConnection = !error;

    if (diagnosticResults.databaseConnection) {
      // Check tables
      for (const table of ['users', 'profiles', 'services', 'bookings']) {
        const { count, error } = await supabase.from(table).select('*', { count: 'exact', head: true });
        diagnosticResults.tables[table].exists = !error;
        diagnosticResults.tables[table].count = count || 0;
      }

      // Check relationships
      const { data: bookingUserData, error: bookingUserError } = await supabase
        .from('bookings')
        .select('id, user_id')
        .limit(1);
      diagnosticResults.relationships.bookings_users = !bookingUserError && bookingUserData && bookingUserData.length > 0;

      const { data: bookingServiceData, error: bookingServiceError } = await supabase
        .from('bookings')
        .select('id, service_id')
        .limit(1);
      diagnosticResults.relationships.bookings_services = !bookingServiceError && bookingServiceData && bookingServiceData.length > 0;

      const { data: profileUserData, error: profileUserError } = await supabase
        .from('profiles')
        .select('id, user_id')
        .limit(1);
      diagnosticResults.relationships.profiles_users = !profileUserError && profileUserData && profileUserData.length > 0;
    }

    // Check payment integration (this is a mock check, replace with actual integration test if available)
    diagnosticResults.paymentIntegration = !!import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY;

  } catch (error) {
    console.error('Diagnostic error:', error);
  }

  return diagnosticResults;
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\generateSitemap.js
import { writeFileSync } from 'fs';
import { globby } from 'globby';

async function generateSitemap() {
  const pages = await globby([
    'src/pages/**/*.jsx',
    '!src/pages/_*.jsx',
    '!src/pages/api',
  ]);

  const sitemap = `
    <?xml version="1.0" encoding="UTF-8"?>
    <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
      ${pages
        .map((page) => {
          const path = page
            .replace('src/pages', '')
            .replace('.jsx', '')
            .replace('/index', '');
          return `
            <url>
              <loc>https://yourdomain.com${path}</loc>
            </url>
          `;
        })
        .join('')}
    </urlset>
  `;

  writeFileSync('public/sitemap.xml', sitemap);
}

export default generateSitemap;


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\imageOptimization.js
import { useState, useEffect } from 'react';

export const useOptimizedImage = (src, options = {}) => {
  const [optimizedSrc, setOptimizedSrc] = useState(src);

  useEffect(() => {
    const img = new Image();
    img.src = src;

    img.onload = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      const { width = img.width, height = img.height, quality = 0.8 } = options;

      canvas.width = width;
      canvas.height = height;

      ctx.drawImage(img, 0, 0, width, height);

      const optimized = canvas.toDataURL('image/jpeg', quality);
      setOptimizedSrc(optimized);
    };
  }, [src, options]);

  return optimizedSrc;
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\insertSampleData.js
import { supabase } from '../config/supabase.config';
import fs from 'fs';
import path from 'path';

const clearAllTables = async () => {
  const tables = ['payments', 'bookings', 'services', 'profiles', 'users'];
  for (const table of tables) {
    const { error } = await supabase.from(table).delete();
    if (error) console.error(`Error clearing table ${table}:`, error);
  }
};

export const resetAndInsertSampleData = async () => {
  try {
    console.log('Clearing all existing data...');
    await clearAllTables();
    
    console.log('Reinserting schema and sample data...');
    const sqlFilePath = path.join(__dirname, '../database/setup.sql');
    const sqlContent = fs.readFileSync(sqlFilePath, 'utf8');
    
    const { data, error } = await supabase.rpc('exec_sql', { sql: sqlContent });
    
    if (error) throw error;
    
    console.log('Database reset and sample data inserted successfully:', data);
  } catch (error) {
    console.error('Error resetting database and inserting sample data:', error);
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\loadTesting.js
import http from 'k6/http';
import { sleep } from 'k6';

export const options = {
  vus: 10,
  duration: '30s',
};

export default function () {
  http.get('http://localhost:5000/');
  sleep(1);
}


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\monitoring.js
import * as Sentry from "@sentry/react";
import { BrowserTracing } from "@sentry/tracing";
import ReactGA from "react-ga4";

const MAX_ERROR_LENGTH = 1000; // Maximum length for error messages

export const initializeMonitoring = () => {
  const sentryDsn = import.meta.env.VITE_SENTRY_DSN;
  if (sentryDsn && sentryDsn !== 'YOUR_SENTRY_DSN_HERE') {
    Sentry.init({
      dsn: sentryDsn,
      integrations: [new BrowserTracing()],
      tracesSampleRate: 0.2, // Reduced from 1.0 to 0.2
      beforeSend(event) {
        // Truncate long error messages
        if (event.message && event.message.length > MAX_ERROR_LENGTH) {
          event.message = event.message.substring(0, MAX_ERROR_LENGTH) + '...';
        }
        // Remove potentially large objects from the extra data
        if (event.extra) {
          Object.keys(event.extra).forEach(key => {
            if (typeof event.extra[key] === 'object' && event.extra[key] !== null) {
              event.extra[key] = '[Object removed to reduce payload size]';
            }
          });
        }
        return event;
      },
    });
  } else {
    console.warn('Sentry DSN is not properly configured. Sentry will not be initialized.');
  }

  const GA_MEASUREMENT_ID = import.meta.env.VITE_GA_MEASUREMENT_ID;
  if (GA_MEASUREMENT_ID && GA_MEASUREMENT_ID !== 'YOUR_GA_MEASUREMENT_ID_HERE') {
    ReactGA.initialize(GA_MEASUREMENT_ID);
  } else {
    console.warn('Google Analytics Measurement ID is not set. GA will not be initialized.');
  }
};

export const logPageView = (path) => {
  if (ReactGA.isInitialized) {
    ReactGA.send({ hitType: "pageview", page: path });
  }
};

export const logEvent = (category, action, label) => {
  if (ReactGA.isInitialized) {
    ReactGA.event({
      category: category,
      action: action,
      label: label,
    });
  }
};

export const logError = (error) => {
  if (Sentry.captureException) {
    // Truncate error message if it's too long
    const truncatedMessage = error.message && error.message.length > MAX_ERROR_LENGTH
      ? error.message.substring(0, MAX_ERROR_LENGTH) + '...'
      : error.message;

    Sentry.captureException(new Error(truncatedMessage), {
      extra: {
        originalError: '[Original error object removed to reduce payload size]'
      }
    });
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\paymentProcessing.js
import axios from 'axios';

export const processPayment = async (amount, paymentMethodId) => {
  try {
    const response = await axios.post('/api/process-payment', {
      amount: Math.round(amount * 100), // Convert to cents
      payment_method_id: paymentMethodId,
    });

    if (response.data.success) {
      return { success: true, paymentIntent: response.data.paymentIntent };
    } else {
      throw new Error(response.data.error || 'Payment processing failed');
    }
  } catch (error) {
    console.error('Error processing payment:', error);
    return { 
      success: false, 
      error: `Payment processing error: ${error.message}`,
      details: error.response?.data || 'No additional details available'
    };
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\testPayment.js
export const testPayment = async (amount) => {
  // Simulate payment processing delay
  await new Promise(resolve => setTimeout(resolve, 1000));

  // Simulate a successful payment most of the time
  const isSuccessful = Math.random() < 0.9;

  if (isSuccessful) {
    return {
      success: true,
      message: 'Payment test successful'
    };
  } else {
    return {
      success: false,
      message: 'Payment test failed. Please try again.'
    };
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\towTruckSelection.js
export const towTruckTypes = {
  A: { perKm: 18.82, basePrice: 528.69, maneuverCharge: 1219.55 },
  C: { perKm: 23.47, basePrice: 721.79, maneuverCharge: 1524.21 },
  D: { perKm: 32.35, basePrice: 885.84, maneuverCharge: 2101.65 },
};

export const getTowTruckType = (vehicleSize) => {
  switch (vehicleSize) {
    case 'small': return 'A';
    case 'medium': return 'C';
    case 'large': return 'D';
    default: return 'A';
  }
};

export const calculateTotalCost = (distance, towTruckType, requiresManeuver) => {
  const { perKm, basePrice, maneuverCharge } = towTruckTypes[towTruckType] || towTruckTypes.A;
  let totalCost = basePrice + (distance * perKm);
  if (requiresManeuver) {
    totalCost += maneuverCharge;
  }
  return Number(totalCost.toFixed(2));
};

export const getVehicleSize = (vehicleModel) => {
  const largeCars = ['Dodge Challenger', 'Dodge Charger', 'Ford F-150', 'Chevrolet Silverado', 'RAM 1500'];
  const trucks = ['Ford F-250', 'Ford F-350', 'Chevrolet Silverado 2500HD', 'RAM 2500', 'RAM 3500'];

  if (trucks.includes(vehicleModel)) return 'large';
  if (largeCars.includes(vehicleModel)) return 'medium';
  return 'small';
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\vehicleData.js
export const vehicleBrands = [
  'Toyota', 'Honda', 'Ford', 'Chevrolet', 'Nissan', 'Volkswagen', 'BMW', 'Mercedes-Benz',
  'Audi', 'Hyundai', 'Mazda', 'Subaru', 'Kia', 'Lexus', 'Volvo', 'Tesla', 'Porsche',
  'Jaguar', 'Land Rover', 'Acura', 'RAM', 'GMC', 'Jeep', 'Dodge', 'Chrysler'
];

export const vehicleModels = {
  Toyota: ['Corolla', 'Camry', 'RAV4', 'Highlander', 'Tacoma', 'Tundra', 'Sienna', 'Prius'],
  Honda: ['Civic', 'Accord', 'CR-V', 'Pilot', 'Odyssey', 'HR-V', 'Fit', 'Ridgeline'],
  Ford: ['F-150', 'Mustang', 'Explorer', 'Escape', 'Focus', 'Ranger', 'Edge', 'Expedition'],
  Chevrolet: ['Silverado', 'Malibu', 'Equinox', 'Traverse', 'Camaro', 'Tahoe', 'Suburban', 'Colorado'],
  Nissan: ['Altima', 'Rogue', 'Sentra', 'Maxima', 'Pathfinder', 'Murano', 'Titan', 'Leaf'],
  Volkswagen: ['Jetta', 'Passat', 'Tiguan', 'Atlas', 'Golf', 'ID.4', 'Arteon', 'Taos'],
  BMW: ['3 Series', '5 Series', 'X3', 'X5', '7 Series', 'M4', 'X1', 'X7'],
  'Mercedes-Benz': ['C-Class', 'E-Class', 'GLC', 'GLE', 'S-Class', 'A-Class', 'GLA', 'GLS'],
  Audi: ['A4', 'A6', 'Q5', 'Q7', 'e-tron', 'A3', 'Q3', 'TT'],
  Hyundai: ['Elantra', 'Sonata', 'Tucson', 'Santa Fe', 'Kona', 'Palisade', 'Venue', 'Ioniq'],
  Mazda: ['Mazda3', 'Mazda6', 'CX-5', 'CX-9', 'MX-5 Miata', 'CX-30', 'CX-3', 'CX-50'],
  Subaru: ['Outback', 'Forester', 'Impreza', 'Crosstrek', 'Legacy', 'Ascent', 'WRX', 'BRZ'],
  Kia: ['Forte', 'Optima', 'Sportage', 'Sorento', 'Telluride', 'Soul', 'Stinger', 'Seltos'],
  Lexus: ['RX', 'ES', 'NX', 'IS', 'GX', 'UX', 'LS', 'LC'],
  Volvo: ['XC90', 'XC60', 'S60', 'V60', 'XC40', 'S90', 'V90', 'C40'],
  Tesla: ['Model 3', 'Model S', 'Model X', 'Model Y', 'Cybertruck', 'Roadster'],
  Porsche: ['911', 'Cayenne', 'Panamera', 'Macan', 'Taycan', 'Boxster', 'Cayman', '718'],
  Jaguar: ['F-PACE', 'XF', 'E-PACE', 'I-PACE', 'XE', 'F-TYPE', 'XJ', 'XK'],
  'Land Rover': ['Range Rover', 'Discovery', 'Defender', 'Evoque', 'Velar'],
  Acura: ['TLX', 'RDX', 'MDX', 'ILX', 'NSX', 'RLX', 'TSX', 'RSX'],
  RAM: ['1500', '2500', '3500', 'ProMaster', 'ProMaster City'],
  GMC: ['Sierra', 'Yukon', 'Terrain', 'Acadia', 'Canyon', 'Savana'],
  Jeep: ['Wrangler', 'Grand Cherokee', 'Cherokee', 'Compass', 'Renegade', 'Gladiator'],
  Dodge: ['Charger', 'Challenger', 'Durango', 'Journey', 'Grand Caravan'],
  Chrysler: ['300', 'Pacifica', 'Voyager']
};

export const vehicleSizes = {
  small: ['Corolla', 'Civic', 'Focus', 'Malibu', 'Sentra', 'Jetta', '3 Series', 'C-Class'],
  medium: ['Camry', 'Accord', 'Mustang', 'Equinox', 'Rogue', 'Passat', '5 Series', 'E-Class'],
  large: ['Tundra', 'Ridgeline', 'F-150', 'Silverado', 'Titan', 'Atlas', 'X7', 'GLS']
};


// C:\Users\israe\Documents\GitHub\grua-booking-system1\src\utils\__tests__\towTruckSelection.test.js
import { getTowTruckType, calculateTotalCost, getVehicleSize } from '../towTruckSelection';

describe('towTruckSelection', () => {
  describe('getTowTruckType', () => {
    it('should return correct tow truck type for vehicle size', () => {
      expect(getTowTruckType('small')).toBe('A');
      expect(getTowTruckType('medium')).toBe('C');
      expect(getTowTruckType('large')).toBe('D');
      expect(getTowTruckType('unknown')).toBe('A');
    });
  });

  describe('calculateTotalCost', () => {
    it('should calculate correct cost without maneuver', () => {
      expect(calculateTotalCost(10, 'A', false)).toBe(717.89);
      expect(calculateTotalCost(10, 'C', false)).toBe(956.49);
      expect(calculateTotalCost(10, 'D', false)).toBe(1209.34);
    });

    it('should calculate correct cost with maneuver', () => {
      expect(calculateTotalCost(10, 'A', true)).toBe(1937.44);
      expect(calculateTotalCost(10, 'C', true)).toBe(2480.70);
      expect(calculateTotalCost(10, 'D', true)).toBe(3310.99);
    });
  });

  describe('getVehicleSize', () => {
    it('should return correct size for known models', () => {
      expect(getVehicleSize('Ford F-150')).toBe('medium');
      expect(getVehicleSize('Ford F-250')).toBe('large');
      expect(getVehicleSize('Toyota Corolla')).toBe('small');
    });

    it('should return "small" for unknown models', () => {
      expect(getVehicleSize('Unknown Model')).toBe('small');
    });
  });
});
