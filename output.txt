

// .\package.json
{
  "name": "vite-project",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "start:dev": "vite --host 0.0.0.0 --port 8080"
  },
  "devDependencies": {
    "@types/react": "^18.3.10",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.2",
    "eslint": "^8.57.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.12",
    "vite": "^5.4.8"
  },
  "dependencies": {
    "@chakra-ui/icons": "^2.1.1",
    "@chakra-ui/react": "^2.8.2",
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@react-google-maps/api": "^2.19.3",
    "@stripe/react-stripe-js": "^2.8.0",
    "@stripe/stripe-js": "^4.5.0",
    "@supabase/auth-ui-react": "^0.4.7",
    "@supabase/auth-ui-shared": "^0.1.8",
    "@supabase/supabase-js": "^2.45.4",
    "@tanstack/react-query": "^5.56.2",
    "@tanstack/react-query-devtools": "^5.0.0",
    "axios": "^1.7.7",
    "axios-retry": "^4.5.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.0",
    "express-validator": "^7.2.0",
    "framer-motion": "^11.9.0",
    "fs": "^0.0.1-security",
    "leaflet": "^1.9.4",
    "react": "^18.3.1",
    "react-datepicker": "^7.4.0",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.0",
    "react-icons": "^5.3.0",
    "react-leaflet": "^4.2.1",
    "react-router-dom": "^6.26.2",
    "stripe": "^17.0.0",
    "uuid": "^10.0.0",
    "winston": "^3.14.2"
  },
  "prettier": {
    "printWidth": 100
  }
}



// C:\Users\israe\Documents\GitHub\grua-booking-system-44\package.json
{
  "name": "vite-project",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "start:dev": "vite --host 0.0.0.0 --port 8080"
  },
  "devDependencies": {
    "@types/react": "^18.3.10",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.2",
    "eslint": "^8.57.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.12",
    "vite": "^5.4.8"
  },
  "dependencies": {
    "@chakra-ui/icons": "^2.1.1",
    "@chakra-ui/react": "^2.8.2",
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@react-google-maps/api": "^2.19.3",
    "@stripe/react-stripe-js": "^2.8.0",
    "@stripe/stripe-js": "^4.5.0",
    "@supabase/auth-ui-react": "^0.4.7",
    "@supabase/auth-ui-shared": "^0.1.8",
    "@supabase/supabase-js": "^2.45.4",
    "@tanstack/react-query": "^5.56.2",
    "@tanstack/react-query-devtools": "^5.0.0",
    "axios": "^1.7.7",
    "axios-retry": "^4.5.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.21.0",
    "express-validator": "^7.2.0",
    "framer-motion": "^11.9.0",
    "fs": "^0.0.1-security",
    "leaflet": "^1.9.4",
    "react": "^18.3.1",
    "react-datepicker": "^7.4.0",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.0",
    "react-icons": "^5.3.0",
    "react-leaflet": "^4.2.1",
    "react-router-dom": "^6.26.2",
    "stripe": "^17.0.0",
    "uuid": "^10.0.0",
    "winston": "^3.14.2"
  },
  "prettier": {
    "printWidth": 100
  }
}



// C:\Users\israe\Documents\GitHub\grua-booking-system-44\vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'), // Enables importing from 'src' as '@'
    },
  },
  server: {
    host: '::',
    port: '8080',
    strictPort: true,
    clearScreen: false,
  },
  plugins: [react()],
});



// C:\Users\israe\Documents\GitHub\grua-booking-system-44\.gpt_engineer_internals\report-url-change.js
const main = () => {
  /**
   * Function to send a message to parent windows
   */
  const postUrlChange = (newUrl) => {
    try {
      const message = { type: "URL_CHANGED", url: newUrl };
      window.top.postMessage(message, "https://run.gptengineer.app");
      window.top.postMessage(message, "http://localhost:3000");
      window.top.postMessage(message, window.origin);
    } catch (error) {
      console.error("Error posting URL change:", error);
    }
  };

  /**
   * Listen for URL changes using MutationObserver and navigation-related events.
   */
  const observeUrlChange = () => {
    let oldHref = document.location.href;

    const checkUrlChange = () => {
      const newHref = document.location.href;
      if (oldHref !== newHref) {
        oldHref = newHref;
        postUrlChange(newHref); // Call the function to post the URL change
      }
    };

    // Observe DOM changes (Fallback for cases not covered by events)
    const body = document.querySelector("body");
    const observer = new MutationObserver(checkUrlChange);
    observer.observe(body, { childList: true, subtree: true });

    // Add event listeners for navigation-related changes
    window.addEventListener("popstate", checkUrlChange); // Back/forward button
    window.addEventListener("hashchange", checkUrlChange); // Hash changes (e.g., #section)

    // Monkey patch pushState and replaceState to capture URL changes triggered by them
    const originalPushState = history.pushState;
    history.pushState = function () {
      originalPushState.apply(this, arguments);
      checkUrlChange();
    };

    const originalReplaceState = history.replaceState;
    history.replaceState = function () {
      originalReplaceState.apply(this, arguments);
      checkUrlChange();
    };
  };

  // Run observeUrlChange when the window is loaded
  window.addEventListener("load", observeUrlChange);
};

// Execute main function (No need for .catch() as this is synchronous)
main();



// C:\Users\israe\Documents\GitHub\grua-booking-system-44\.vscode\launch.json
{
    // Use IntelliSense para saber los atributos posibles.
    // Mantenga el puntero para ver las descripciones de los existentes atributos.
    // Para más información, visite: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "PowerShell: Launch Current File",
            "type": "PowerShell",
            "request": "launch",
            "script": "${file}",
            "args": []
        }
    ]
}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\scripts\update-package-json.js
const fs = require('fs');
const path = require('path');

const packageJsonPath = path.join(__dirname, '..', 'package.json');

try {
  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));

  if (!packageJson.scripts['build:dev']) {
    packageJson.scripts['build:dev'] = 'vite build --mode development';

    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    console.log('Successfully added build:dev script to package.json');
  } else {
    console.log('build:dev script already exists in package.json');
  }
} catch (error) {
  console.error('Error updating package.json:', error);

  // Replace process.exit(1) with more browser-friendly error handling
  if (typeof window === 'undefined') {
    // Node.js environment
    process.exit(1);
  } else {
    // Browser environment or other runtime
    throw new Error('Failed to update package.json');
  }
}



// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\setupSampleData.js
import { insertSampleData } from './utils/insertSampleData';

insertSampleData()
  .then(() => console.log('Sample data setup complete'))
  .catch(error => console.error('Error setting up sample data:', error));


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\theme.js
// theme.js
import { extendTheme } from "@chakra-ui/react";

const theme = extendTheme({
  colors: {
    primary: "#ff6347",
    secondary: "#4a5568",
  },
  fonts: {
    body: "system-ui, sans-serif",
    heading: "Georgia, serif",
  },
});

export default theme;



// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\authentication\authentication.domain.facade.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AuthenticationDomainFacade {
  private users: Map<string, string> = new Map();

  constructor() {
    // Initialize with some default users
    this.users.set('user1', 'password1');
    this.users.set('user2', 'password2');
  }

  public authenticate(username: string, password: string): boolean {
    const storedPassword = this.users.get(username);
    return storedPassword === password;
  }

  public addUser(username: string, password: string): void {
    this.users.set(username, password);
  }

  public removeUser(username: string): void {
    this.users.delete(username);
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\authentication\authentication.domain.module.ts
import { Module } from '@nestjs/common';
import { AuthenticationDomainFacade } from './authentication.domain.facade';

@Module({
  providers: [AuthenticationDomainFacade],
  exports: [AuthenticationDomainFacade],
})
export class AuthenticationDomainModule {}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\config\stripe.js
import { loadStripe } from '@stripe/stripe-js';

const stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY);

export default stripePromise;


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\config\supabase.config.ts
import { createClient } from '@supabase/supabase-js';

export const supabaseUrl = import.meta.env.VITE_SUPABASE_PROJECT_URL;
export const supabaseKey = import.meta.env.VITE_SUPABASE_API_KEY;

const supabase = createClient(supabaseUrl, supabaseKey);

export default supabase;


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\constants\roles.js
export const ROLES = {
  USER: 'user',
  ADMIN: 'admin',
  SUPER_ADMIN: 'super_admin'
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\event\event.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class EventService {
  private events: any[] = [];

  emit(event: any) {
    this.events.push(event);
    console.log('Event emitted:', event);
  }

  getEvents() {
    return this.events;
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\hooks\useBookingForm.js
import { useState, useCallback, useEffect } from 'react';
import { useToast } from "@chakra-ui/react";
import { useNavigate } from "react-router-dom";
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useSupabaseAuth } from '../integrations/supabase/auth';
import { createBooking } from '../server/db';
import { testPayment } from '../utils/testPayment';
import { getTowTruckType, calculateTotalCost } from '../utils/towTruckSelection';

export const useBookingForm = () => {
  const [formData, setFormData] = useState(() => {
    const savedData = localStorage.getItem('bookingFormData');
    return savedData ? JSON.parse(savedData) : {
      serviceType: '',
      userName: '',
      phoneNumber: '',
      vehicleBrand: '',
      vehicleModel: '',
      vehicleColor: '',
      licensePlate: '',
      vehicleSize: '',
      pickupAddress: '',
      dropOffAddress: '',
      vehicleIssue: '',
      additionalDetails: '',
      wheelsStatus: '',
      pickupDateTime: new Date(),
      paymentMethod: 'card',
    };
  });

  const [distance, setDistance] = useState(0);
  const [totalCost, setTotalCost] = useState(0);
  const [selectedTowTruck, setSelectedTowTruck] = useState('');
  const [isPaymentWindowOpen, setIsPaymentWindowOpen] = useState(false);

  const navigate = useNavigate();
  const { session } = useSupabaseAuth();
  const toast = useToast();
  const queryClient = useQueryClient();
  const testModeUser = JSON.parse(localStorage.getItem('testModeUser'));

  const createBookingMutation = useMutation({
    mutationFn: createBooking,
    onSuccess: () => {
      queryClient.invalidateQueries('bookings');
      toast({
        title: 'Booking created.',
        description: "We've created your booking for you.",
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
      navigate('/confirmation');
    },
    onError: (error) => {
      toast({
        title: 'An error occurred.',
        description: error.message,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    },
  });

  const handleChange = useCallback((e) => {
    const { name, value } = e.target;
    setFormData(prevData => ({
      ...prevData,
      [name]: value
    }));

    if (name === 'vehicleBrand') {
      setFormData(prevData => ({
        ...prevData,
        vehicleModel: ''
      }));
    }

    if (name === 'vehicleModel') {
      const vehicleSize = getVehicleSize(value);
      const towTruckType = getTowTruckType(vehicleSize);
      setFormData(prevData => ({
        ...prevData,
        vehicleSize: vehicleSize
      }));
      setSelectedTowTruck(towTruckType);
      updateTotalCost(distance, towTruckType);
    }
  }, [distance]);

  const handleDateTimeChange = useCallback((date) => {
    setFormData(prevData => ({
      ...prevData,
      pickupDateTime: date
    }));
  }, []);

  const updateTotalCost = useCallback((distance, towTruckType) => {
    const cost = calculateTotalCost(distance, towTruckType);
    setTotalCost(cost);
  }, []);

  const handleBookingProcess = useCallback(async () => {
    if (!session && !testModeUser) {
      toast({
        title: 'Authentication required',
        description: 'Please log in to create a booking.',
        status: 'warning',
        duration: 5000,
        isClosable: true,
      });
      return;
    }

    if (!formData.serviceType || !formData.userName || !formData.phoneNumber || !formData.vehicleBrand || !formData.vehicleModel) {
      toast({
        title: 'Incomplete Form',
        description: 'Please fill in all required fields.',
        status: 'warning',
        duration: 5000,
        isClosable: true,
      });
      return;
    }

    const testResult = await testPayment(totalCost);
    if (!testResult.success) {
      toast({
        title: 'Payment Test Failed',
        description: testResult.message,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return;
    }

    setIsPaymentWindowOpen(true);
  }, [session, testModeUser, toast, formData, totalCost]);

  useEffect(() => {
    localStorage.setItem('bookingFormData', JSON.stringify(formData));
  }, [formData]);

  return {
    formData,
    setFormData,
    distance,
    setDistance,
    totalCost,
    setTotalCost,
    selectedTowTruck,
    isPaymentWindowOpen,
    setIsPaymentWindowOpen,
    handleChange,
    handleDateTimeChange,
    handleBookingProcess,
    createBookingMutation,
  };
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\hooks\useBookings.js
import { useQuery } from '@tanstack/react-query';
import { getBookings } from '../server/db';
import { useToast } from '@chakra-ui/react';

export const useBookings = () => {
  const toast = useToast();

  return useQuery({
    queryKey: ['bookings'],
    queryFn: getBookings,
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    refetchOnWindowFocus: false,
    onError: (error) => {
      console.error('Failed to fetch bookings:', error);
      toast({
        title: 'Error fetching bookings',
        description: 'Please try again later or contact support if the problem persists.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    },
  });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\hooks\usePaymentSubmit.js
import { useCallback } from 'react';
import { useToast } from "@chakra-ui/react";
import { useQueryClient } from '@tanstack/react-query';
import { useSupabaseAuth } from '../integrations/supabase/auth';
import { sendAdminNotification } from '../utils/adminNotification';

export const usePaymentSubmit = (formData, totalCost, createBookingMutation, setIsPaymentWindowOpen) => {
  const { session } = useSupabaseAuth();
  const toast = useToast();
  const queryClient = useQueryClient();

  const handlePaymentSubmit = useCallback(async (paymentMethod) => {
    setIsPaymentWindowOpen(false);

    try {
      const response = await fetch('/api/process-payment', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          paymentMethodId: paymentMethod.id,
          amount: totalCost * 100, // Convert to cents
        }),
      });

      if (!response.ok) {
        throw new Error('Payment processing failed');
      }

      const result = await response.json();

      if (result.success) {
        const bookingData = {
          ...formData,
          userId: session?.user?.id || 'test_user_id',
          totalCost,
          paymentIntentId: result.paymentIntentId,
          status: 'paid',
          payment_status: 'paid'
        };

        try {
          await createBookingMutation.mutateAsync(bookingData);
          await sendAdminNotification(bookingData, totalCost);

          toast({
            title: 'Booking Confirmed',
            description: 'Your booking has been successfully created and payment processed.',
            status: 'success',
            duration: 5000,
            isClosable: true,
          });

          queryClient.invalidateQueries('bookings');
        } catch (bookingError) {
          console.error('Error creating booking:', bookingError);
          toast({
            title: 'Booking Error',
            description: 'Your payment was successful, but there was an issue creating your booking. Our team has been notified and will contact you shortly.',
            status: 'warning',
            duration: 7000,
            isClosable: true,
          });
        }
      } else {
        throw new Error('Payment processing failed');
      }
    } catch (error) {
      console.error('Payment Error:', error);
      toast({
        title: 'Payment Error',
        description: 'We encountered an issue processing your payment. Please try again or contact our support team.',
        status: 'error',
        duration: 7000,
        isClosable: true,
      });
    }
  }, [formData, session, totalCost, createBookingMutation, toast, queryClient, setIsPaymentWindowOpen]);

  return handlePaymentSubmit;
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\hooks\useUsers.js
import { useQuery } from '@tanstack/react-query';
import { getUsers } from '../server/db';
import { useToast } from '@chakra-ui/react';

export const useUsers = () => {
  const toast = useToast();

  return useQuery({
    queryKey: ['users'],
    queryFn: getUsers,
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    refetchOnWindowFocus: false,
    onError: (error) => {
      console.error('Failed to fetch users:', error);
      toast({
        title: 'Error fetching users',
        description: 'Please try again later or contact support if the problem persists.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    },
  });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\integrations\supabase\openapi.json
{"swagger":"2.0","info":{"description":"","title":"standard public schema","version":"12.1 (8cbcf98)"},"host":"gjwhxrajesykwmomorhw.supabase.co:443","basePath":"/","schemes":["https"],"consumes":["application/json","application/vnd.pgrst.object+json;nulls=stripped","application/vnd.pgrst.object+json","text/csv"],"produces":["application/json","application/vnd.pgrst.object+json;nulls=stripped","application/vnd.pgrst.object+json","text/csv"],"paths":{"/":{"get":{"produces":["application/openapi+json","application/json"],"responses":{"200":{"description":"OK"}},"summary":"OpenAPI description (this document)","tags":["Introspection"]}},"/TOW":{"get":{"parameters":[{"$ref":"#/parameters/rowFilter.TOW.id"},{"$ref":"#/parameters/rowFilter.TOW.created_at"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/order"},{"$ref":"#/parameters/range"},{"$ref":"#/parameters/rangeUnit"},{"$ref":"#/parameters/offset"},{"$ref":"#/parameters/limit"},{"$ref":"#/parameters/preferCount"}],"responses":{"200":{"description":"OK","schema":{"items":{"$ref":"#/definitions/TOW"},"type":"array"}},"206":{"description":"Partial Content"}},"summary":"TOW","tags":["TOW"]},"post":{"parameters":[{"$ref":"#/parameters/body.TOW"},{"$ref":"#/parameters/select"},{"$ref":"#/parameters/preferPost"}],"responses":{"201":{"description":"Created"}},"summary":"TOW","tags":["TOW"]},"delete":{"parameters":[{"$ref":"#/parameters/rowFilter.TOW.id"},{"$ref":"#/parameters/rowFilter.TOW.created_at"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"summary":"TOW","tags":["TOW"]},"patch":{"parameters":[{"$ref":"#/parameters/rowFilter.TOW.id"},{"$ref":"#/parameters/rowFilter.TOW.created_at"},{"$ref":"#/parameters/body.TOW"},{"$ref":"#/parameters/preferReturn"}],"responses":{"204":{"description":"No Content"}},"summary":"TOW","tags":["TOW"]}}},"definitions":{"TOW":{"description":"TOW","required":["id","created_at"],"properties":{"id":{"description":"Note:\nThis is a Primary Key.<pk/>","format":"bigint","type":"integer"},"created_at":{"default":"now()","format":"timestamp with time zone","type":"string"}},"type":"object"}},"parameters":{"preferParams":{"name":"Prefer","description":"Preference","required":false,"enum":["params=single-object"],"in":"header","type":"string"},"preferReturn":{"name":"Prefer","description":"Preference","required":false,"enum":["return=representation","return=minimal","return=none"],"in":"header","type":"string"},"preferCount":{"name":"Prefer","description":"Preference","required":false,"enum":["count=none"],"in":"header","type":"string"},"preferPost":{"name":"Prefer","description":"Preference","required":false,"enum":["return=representation","return=minimal","return=none","resolution=ignore-duplicates","resolution=merge-duplicates"],"in":"header","type":"string"},"select":{"name":"select","description":"Filtering Columns","required":false,"in":"query","type":"string"},"on_conflict":{"name":"on_conflict","description":"On Conflict","required":false,"in":"query","type":"string"},"order":{"name":"order","description":"Ordering","required":false,"in":"query","type":"string"},"range":{"name":"Range","description":"Limiting and Pagination","required":false,"in":"header","type":"string"},"rangeUnit":{"name":"Range-Unit","description":"Limiting and Pagination","required":false,"default":"items","in":"header","type":"string"},"offset":{"name":"offset","description":"Limiting and Pagination","required":false,"in":"query","type":"string"},"limit":{"name":"limit","description":"Limiting and Pagination","required":false,"in":"query","type":"string"},"body.TOW":{"name":"TOW","description":"TOW","required":false,"in":"body","schema":{"$ref":"#/definitions/TOW"}},"rowFilter.TOW.id":{"name":"id","required":false,"format":"bigint","in":"query","type":"string"},"rowFilter.TOW.created_at":{"name":"created_at","required":false,"format":"timestamp with time zone","in":"query","type":"string"}},"externalDocs":{"description":"PostgREST Documentation","url":"https://postgrest.org/en/v12.1/api.html"}}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\db.js
import { createClient } from '@supabase/supabase-js';
import { ROLES } from '../constants/roles';

const supabaseUrl = import.meta.env.VITE_SUPABASE_PROJECT_URL;
const supabaseKey = import.meta.env.VITE_SUPABASE_API_KEY;

const supabase = createClient(supabaseUrl, supabaseKey);

// Helper function to handle Supabase errors with retry logic
const handleSupabaseError = async (operation) => {
  const maxRetries = 3;
  let retries = 0;

  while (retries < maxRetries) {
    try {
      const result = await operation();
      return result;
    } catch (error) {
      console.error('Supabase error:', error);
      retries++;
      if (retries === maxRetries) {
        throw new Error(error.message || 'An unexpected error occurred');
      }
      // Wait for a short time before retrying
      await new Promise(resolve => setTimeout(resolve, 1000 * retries));
    }
  }
};

export const getUsers = async () => {
  return handleSupabaseError(async () => {
    const { data, error } = await supabase
      .from('users')
      .select('id, username, email, created_at');
    if (error) throw error;
    return data;
  });
};

export const getBookings = async () => {
  return handleSupabaseError(async () => {
    const { data, error } = await supabase
      .from('bookings')
      .select('*, users(username)')
      .order('created_at', { ascending: false });
    if (error) throw error;
    return data;
  });
};

export const getPaidBookings = async () => {
  return handleSupabaseError(async () => {
    const { data, error } = await supabase
      .from('bookings')
      .select('*, users(username)')
      .eq('payment_status', 'paid')
      .order('created_at', { ascending: false });
    if (error) throw error;
    return data;
  });
};

export const createUser = async (userData) => {
  return handleSupabaseError(async () => {
    const { data, error } = await supabase
      .from('users')
      .insert({
        username: userData.username,
        email: userData.email,
        password_hash: userData.password_hash // Note: Ensure proper hashing is done before this step
      });
    if (error) throw error;
    return data;
  });
};

export const updateUser = async (id, userData) => {
  return handleSupabaseError(async () => {
    const { data, error } = await supabase
      .from('users')
      .update(userData)
      .eq('id', id);
    if (error) throw error;
    return data;
  });
};

export const deleteUser = async (id) => {
  return handleSupabaseError(async () => {
    const { data, error } = await supabase
      .from('users')
      .delete()
      .eq('id', id);
    if (error) throw error;
    return data;
  });
};

export const createBooking = async (bookingData) => {
  return handleSupabaseError(async () => {
    const { data, error } = await supabase
      .from('bookings')
      .insert(bookingData);
    if (error) throw error;
    return data;
  });
};

export const updateBooking = async (id, bookingData) => {
  return handleSupabaseError(async () => {
    const { data, error } = await supabase
      .from('bookings')
      .update(bookingData)
      .eq('id', id);
    if (error) throw error;
    return data;
  });
};

export const deleteBooking = async (id) => {
  return handleSupabaseError(async () => {
    const { data, error } = await supabase
      .from('bookings')
      .delete()
      .eq('id', id);
    if (error) throw error;
    return data;
  });
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\server.js
const express = require('express');
const cors = require('cors');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const { createBooking } = require('./controllers/bookingController');
const { createAdminUser, getPaidServices, updateService } = require('./controllers/adminController');
const { getSettings, updateSetting } = require('./controllers/settingsController');

const app = express();

app.use(cors());
app.use(express.json());

app.post('/api/bookings', createBooking);
app.post('/api/admin/create', createAdminUser);
app.get('/api/admin/paid-services', getPaidServices);
app.put('/api/admin/services/:id', updateService);
app.get('/api/settings', getSettings);
app.put('/api/settings/:key', updateSetting);

app.post('/api/process-payment', async (req, res) => {
  const { paymentMethodId, amount } = req.body;

  try {
    const paymentIntent = await stripe.paymentIntents.create({
      amount,
      currency: 'usd',
      payment_method: paymentMethodId,
      confirm: true,
    });

    res.json({ success: true, paymentIntentId: paymentIntent.id });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));



// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\config\config.js
require('dotenv').config();

module.exports = {
  port: process.env.PORT || 5000,
  supabaseUrl: process.env.VITE_SUPABASE_PROJECT_URL,
  supabaseKey: process.env.VITE_SUPABASE_API_KEY,
  stripeSecretKey: process.env.STRIPE_SECRET_KEY,
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\config\database.js
const { createClient } = require('@supabase/supabase-js');

const supabaseUrl = process.env.VITE_SUPABASE_PROJECT_URL;
const supabaseKey = process.env.VITE_SUPABASE_API_KEY;

const supabase = createClient(supabaseUrl, supabaseKey);

module.exports = supabase;


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\controllers\adminController.js
const supabase = require('../config/database');

exports.createAdmin = async (req, res, next) => {
  try {
    const { data, error } = await supabase
      .from('users')
      .insert({ ...req.body, is_admin: true });

    if (error) throw error;

    res.status(201).json({ success: true, data: data[0] });
  } catch (error) {
    next(error);
  }
};

exports.getPaidServices = async (req, res, next) => {
  try {
    const { data, error } = await supabase
      .from('services_logs')
      .select('*')
      .eq('status', 'paid')
      .order('created_at', { ascending: false });

    if (error) throw error;

    res.status(200).json({ success: true, data });
  } catch (error) {
    next(error);
  }
};

exports.updateService = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    const { data, error } = await supabase
      .from('services_logs')
      .update({ status })
      .eq('id', id);

    if (error) throw error;

    res.status(200).json({ success: true, data: data[0] });
  } catch (error) {
    next(error);
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\controllers\bookingController.js
const supabase = require('../config/database');
const { sendAdminNotification } = require('../../utils/adminNotification');
const { logger } = require('../middleware/errorHandler');

exports.createBooking = async (req, res, next) => {
  try {
    const bookingData = {
      profile_id: req.body.userId,
      service_id: req.body.serviceId,
      status: 'pending',
      total_cost: req.body.totalCost,
      payment_status: 'pending',
      user_id: req.user.id
    };

    const { data: createdBooking, error: bookingError } = await supabase
      .from('bookings')
      .insert(bookingData);
    
    if (bookingError) throw bookingError;

    logger.info(`New booking created: ${JSON.stringify(createdBooking)}`);
    
    try {
      await sendAdminNotification(createdBooking[0], createdBooking[0].total_cost);
    } catch (notificationError) {
      logger.error(`Failed to send admin notification: ${notificationError.message}`);
      // Continue execution even if notification fails
    }

    res.status(201).json({
      success: true,
      message: 'Booking created successfully',
      booking: createdBooking[0]
    });
  } catch (error) {
    logger.error(`Error creating booking: ${error.message}`);
    next(error);
  }
};

exports.getAllBookings = async (req, res, next) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const startIndex = (page - 1) * limit;

    const { data, error, count } = await supabase
      .from('services_logs')
      .select('*, profiles(full_name), services(service_name)', { count: 'exact' })
      .range(startIndex, startIndex + limit - 1);
    
    if (error) throw error;

    res.status(200).json({
      success: true,
      count,
      data,
      totalPages: Math.ceil(count / limit),
      currentPage: page
    });
  } catch (error) {
    logger.error(`Error fetching bookings: ${error.message}`);
    next(error);
  }
};

exports.getBookingById = async (req, res, next) => {
  try {
    const { data, error } = await supabase
      .from('services_logs')
      .select('*, profiles(full_name), services(service_name)')
      .eq('id', req.params.id)
      .single();
    
    if (error) throw error;
    if (!data) {
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }

    res.status(200).json({
      success: true,
      data
    });
  } catch (error) {
    logger.error(`Error fetching booking by ID: ${error.message}`);
    next(error);
  }
};

exports.updateBooking = async (req, res, next) => {
  try {
    const { data, error } = await supabase
      .from('services_logs')
      .update(req.body)
      .eq('id', req.params.id);
    
    if (error) throw error;

    res.status(200).json({
      success: true,
      message: 'Booking updated successfully',
      data: data[0]
    });
  } catch (error) {
    logger.error(`Error updating booking: ${error.message}`);
    next(error);
  }
};

exports.deleteBooking = async (req, res, next) => {
  try {
    const { error } = await supabase
      .from('services_logs')
      .delete()
      .eq('id', req.params.id);
    
    if (error) throw error;

    res.status(200).json({
      success: true,
      message: 'Booking deleted successfully'
    });
  } catch (error) {
    logger.error(`Error deleting booking: ${error.message}`);
    next(error);
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\controllers\settingsController.js
const supabase = require('../config/database');

exports.getAllSettings = async (req, res, next) => {
  try {
    const { data, error } = await supabase
      .from('settings')
      .select('*');

    if (error) throw error;

    res.status(200).json({
      success: true,
      data
    });
  } catch (error) {
    next(error);
  }
};

exports.updateSetting = async (req, res, next) => {
  try {
    const { key, value } = req.body;
    const { data, error } = await supabase
      .from('settings')
      .upsert({ key, value })
      .select();

    if (error) throw error;

    res.status(200).json({
      success: true,
      data: data[0]
    });
  } catch (error) {
    next(error);
  }
};

exports.deleteSetting = async (req, res, next) => {
  try {
    const { key } = req.params;
    const { error } = await supabase
      .from('settings')
      .delete()
      .eq('key', key);

    if (error) throw error;

    res.status(200).json({
      success: true,
      message: 'Setting deleted successfully'
    });
  } catch (error) {
    next(error);
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\middleware\errorHandler.js
const winston = require('winston');

const logger = winston.createLogger({
  level: 'error',
  format: winston.format.json(),
  defaultMeta: { service: 'user-service' },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.Console({ format: winston.format.simple() })
  ]
});

const errorHandler = (err, req, res, next) => {
  logger.error(`${err.status || 500} - ${err.message} - ${req.originalUrl} - ${req.method} - ${req.ip}`);

  res.status(err.status || 500).json({
    error: {
      message: err.message || 'Internal Server Error',
    },
  });
};

module.exports = { errorHandler, logger };


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\middleware\inputValidation.js
const { body, validationResult } = require('express-validator');

const validateBookingInput = [
  body('userName').notEmpty().withMessage('User name is required'),
  body('phoneNumber').notEmpty().withMessage('Phone number is required'),
  body('serviceType').notEmpty().withMessage('Service type is required'),
  body('pickupAddress').notEmpty().withMessage('Pickup address is required'),
  body('dropOffAddress').notEmpty().withMessage('Drop off address is required'),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    next();
  },
];

module.exports = { validateBookingInput };


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\routes\adminRoutes.js
const express = require('express');
const router = express.Router();
const adminController = require('../controllers/adminController');

router.post('/create', adminController.createAdmin);
router.get('/services', adminController.getPaidServices);
router.put('/services/:id', adminController.updateService);

module.exports = router;


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\routes\bookingRoutes.js
const express = require('express');
const router = express.Router();
const bookingController = require('../controllers/bookingController');
const { validateBookingInput } = require('../middleware/inputValidation');

router.post('/', validateBookingInput, bookingController.createBooking);
router.get('/', bookingController.getAllBookings);
router.get('/:id', bookingController.getBookingById);
router.put('/:id', validateBookingInput, bookingController.updateBooking);
router.delete('/:id', bookingController.deleteBooking);

module.exports = router;


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\server\routes\settingsRoutes.js
const express = require('express');
const router = express.Router();
const settingsController = require('../controllers/settingsController');

router.get('/', settingsController.getAllSettings);
router.post('/', settingsController.updateSetting);
router.delete('/:key', settingsController.deleteSetting);

module.exports = router;


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\towingRequest\towingRequest.domain.facade.ts
import { Injectable } from '@nestjs/common';
import { TowingRequest } from './towingRequest.entity';

@Injectable()
export class TowingRequestDomainFacade {
  private towingRequests: TowingRequest[] = [];

  public findAll(): TowingRequest[] {
    return this.towingRequests;
  }

  public createOne(createDto: TowingRequest): TowingRequest {
    const newRequest = { ...createDto, id: Date.now().toString() };
    this.towingRequests.push(newRequest);
    return newRequest;
  }

  public findById(id: string): TowingRequest | undefined {
    return this.towingRequests.find(request => request.id === id);
  }

  public updateOne(id: string, updateDto: Partial<TowingRequest>): TowingRequest | undefined {
    const requestIndex = this.towingRequests.findIndex(request => request.id === id);
    if (requestIndex > -1) {
      this.towingRequests[requestIndex] = { ...this.towingRequests[requestIndex], ...updateDto };
      return this.towingRequests[requestIndex];
    }
    return undefined;
  }

  public deleteOne(id: string): boolean {
    const requestIndex = this.towingRequests.findIndex(request => request.id === id);
    if (requestIndex > -1) {
      this.towingRequests.splice(requestIndex, 1);
      return true;
    }
    return false;
  }

  public findByUserId(userId: string): TowingRequest[] {
    return this.towingRequests.filter(request => request.userId === userId);
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\towingRequest\towingRequest.domain.module.ts
import { Module } from '@nestjs/common';
import { TowingRequestDomainFacade } from './towingRequest.domain.facade';

@Module({
  providers: [TowingRequestDomainFacade],
  exports: [TowingRequestDomainFacade],
})
export class TowingRequestDomainModule {}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\towingRequest\towingRequest.entity.ts
export class TowingRequest {
  id: string;
  userId: string;
  pickupLocation: string;
  destinationLocation: string;
  additionalInfo?: string;
}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\towingRequest\application\towingRequest.application.event.ts
export namespace TowingRequestApplicationEvent {
  export class TowingRequestCreated {
    static readonly key = 'towingRequest.created';
    constructor(public readonly id: string, public readonly userId: string) {}
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\towingRequest\application\towingRequest.application.module.ts
import { Module } from '@nestjs/common';
import { AuthenticationDomainModule } from '../authentication/authentication.domain.module';
import { TowingRequestDomainModule } from '../towing-request/towingRequest.domain.module';
import { UserDomainModule } from '../user/user.domain.module';

import { EventService } from '../event/event.service';
import { TowingRequestDomainFacade } from '../towingRequest/towingRequest.domain.facade';
import { AuthenticationDomainFacade } from '../authentication/authentication.domain.facade';
import { NewService } from '../new/new.service';

@Module({
  imports: [
    AuthenticationDomainModule,
    TowingRequestDomainModule,
    UserDomainModule,
  ],
  
  providers: [
    EventService,
    TowingRequestDomainFacade,
    {
      provide: 'AuthenticationDomainFacade',
      useClass: AuthenticationDomainFacade,
    },
    NewService,
  ],
})
export class TowingRequestApplicationModule {}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\towingRequest\application\towingRequest.controller.ts
import { Controller, Get, Post, Patch, Delete, Body, Param } from '@nestjs/common';
import { EventService } from '../event/event.service';
import { TowingRequestDomainFacade } from '../towingRequest/towingRequest.domain.facade';
import { AuthenticationDomainFacade } from '../authentication/authentication.domain.facade';
import { TowingRequestCreateDto, TowingRequestUpdateDto } from './towingRequest.dto';
import { TowingRequestApplicationEvent } from './towingRequest.application.event';
import { supabaseUrl, supabaseKey } from '../../config/supabase.config';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(supabaseUrl, supabaseKey);

@Controller('/v1/towingRequests')
export class TowingRequestController {
  constructor(
    private readonly eventService: EventService,
    private readonly towingRequestDomainFacade: TowingRequestDomainFacade,
    private readonly authenticationDomainFacade: AuthenticationDomainFacade,
  ) {}

  @Get()
  async findMany() {
    return this.towingRequestDomainFacade.findMany();
  }

  @Post()
  async create(@Body() createDto: TowingRequestCreateDto) {
    const towingRequest = await this.towingRequestDomainFacade.create(createDto);
    this.eventService.emit(new TowingRequestApplicationEvent.TowingRequestCreated(towingRequest.id, towingRequest.userId));
    return towingRequest;
  }

  @Post('/create')
  async createTowingRequest(@Body() createDto: TowingRequestCreateDto) {
    const { data, error } = await supabase
      .from('TOW')
      .insert([createDto]);

    if (error) {
      throw new Error(error.message);
    }

    return data;
  }

  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.towingRequestDomainFacade.findOne(id);
  }

  @Patch(':id')
  async update(@Param('id') id: string, @Body() updateDto: TowingRequestUpdateDto) {
    return this.towingRequestDomainFacade.update(id, updateDto);
  }

  @Delete(':id')
  async delete(@Param('id') id: string) {
    return this.towingRequestDomainFacade.delete(id);
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\towingRequest\application\towingRequest.dto.ts
import { IsString, IsNotEmpty, IsOptional, Matches } from 'class-validator';

export class TowingRequestCreateDto {
  @IsString()
  @IsNotEmpty()
  @Matches(/^[a-zA-Z0-9\s,'-]*$/, {
    message: 'Pickup location must be a valid address',
  })
  pickupLocation: string;

  @IsString()
  @IsNotEmpty()
  @Matches(/^[a-zA-Z0-9\s,'-]*$/, {
    message: 'Destination location must be a valid address',
  })
  destinationLocation: string;

  @IsString()
  @IsOptional()
  additionalInfo?: string;
}

export class TowingRequestUpdateDto {
  @IsString()
  @IsOptional()
  @Matches(/^[a-zA-Z0-9\s,'-]*$/, {
    message: 'Pickup location must be a valid address',
  })
  pickupLocation?: string;

  @IsString()
  @IsOptional()
  @Matches(/^[a-zA-Z0-9\s,'-]*$/, {
    message: 'Destination location must be a valid address',
  })
  destinationLocation?: string;

  @IsString()
  @IsOptional()
  additionalInfo?: string;
}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\towingRequest\application\towingRequestByUser.controller.ts
import { Controller, Get, Param } from '@nestjs/common';
import { TowingRequestDomainFacade } from '../towingRequest/towingRequest.domain.facade';

@Controller('/v1/users/:userId/towingRequests')
export class TowingRequestByUserController {
  constructor(private readonly towingRequestDomainFacade: TowingRequestDomainFacade) {}

  @Get()
  async findByUser(@Param('userId') userId: string) {
    return this.towingRequestDomainFacade.findByUser(userId);
  }
}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\user\user.domain.module.ts
import { Module } from '@nestjs/common';

@Module({})
export class UserDomainModule {}


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\utils\adminNotification.js
import { supabase } from '../integrations/supabase/index.jsx';

export const sendAdminNotification = async (bookingData, totalCost) => {
  try {
    const notificationData = {
      service_type: bookingData.serviceType,
      user_name: bookingData.userName,
      phone_number: bookingData.phoneNumber,
      vehicle_make: bookingData.vehicleBrand,
      vehicle_model: bookingData.vehicleModel,
      vehicle_size: bookingData.vehicleSize,
      total_cost: totalCost,
      status: 'paid',
      created_at: new Date().toISOString(),
    };

    const { data, error } = await supabase
      .from('admin_notifications')
      .insert([notificationData]);

    if (error) throw error;
    console.log('Admin notification sent successfully:', data);

    // Send a real-time notification to admin users
    await supabase
      .from('admin_notifications')
      .on('INSERT', (payload) => {
        console.log('New admin notification:', payload.new);
        // Here you can implement additional logic to notify admins in real-time
        // For example, you could use a websocket or push notification service
      })
      .subscribe();

    return data;
  } catch (error) {
    console.error('Error sending admin notification:', error);
    throw new Error('Failed to send admin notification');
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\utils\adminUtils.js
import supabase from '../config/supabase.config';

export const ROLES = {
  USER: 'user',
  ADMIN: 'admin',
  SUPER_ADMIN: 'super_admin'
};

export const isAdmin = async (userId) => {
  const { data, error } = await supabase
    .from('users')
    .select('role')
    .eq('id', userId)
    .single();

  if (error) {
    console.error('Error checking admin status:', error);
    return false;
  }

  return data?.role === ROLES.ADMIN || data?.role === ROLES.SUPER_ADMIN;
};

export const isSuperAdmin = async (userId) => {
  const { data, error } = await supabase
    .from('users')
    .select('role')
    .eq('id', userId)
    .single();

  if (error) {
    console.error('Error checking super admin status:', error);
    return false;
  }

  return data?.role === ROLES.SUPER_ADMIN;
};

export const getAdminUsers = async () => {
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .in('role', [ROLES.ADMIN, ROLES.SUPER_ADMIN]);

  if (error) {
    console.error('Error fetching admin users:', error);
    return [];
  }

  return data || [];
};

export const setUserRole = async (userId, role) => {
  const { data, error } = await supabase
    .from('users')
    .update({ role })
    .eq('id', userId);

  if (error) {
    console.error('Error updating user role:', error);
    return false;
  }

  return true;
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\utils\insertSampleData.js
import { supabase } from '../config/supabase.config';
import fs from 'fs';
import path from 'path';

export const insertSampleData = async () => {
  try {
    const sqlFilePath = path.join(__dirname, '../database/sample_data.sql');
    const sqlContent = fs.readFileSync(sqlFilePath, 'utf8');
    
    const { data, error } = await supabase.rpc('exec_sql', { sql: sqlContent });
    
    if (error) throw error;
    
    console.log('Sample data inserted successfully:', data);
  } catch (error) {
    console.error('Error inserting sample data:', error);
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\utils\paymentProcessing.js
import axios from 'axios';

export const processPayment = async (amount, paymentMethodId) => {
  try {
    const response = await axios.post('/api/process-payment', {
      amount: Math.round(amount * 100), // Convert to cents
      payment_method_id: paymentMethodId,
    });

    if (response.data.success) {
      return { success: true, paymentIntent: response.data.paymentIntent };
    } else {
      throw new Error(response.data.error || 'Payment processing failed');
    }
  } catch (error) {
    console.error('Error processing payment:', error);
    return { success: false, error: error.message };
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\utils\testPayment.js
export const testPayment = async (amount) => {
  // Simulate payment processing delay
  await new Promise(resolve => setTimeout(resolve, 1000));

  // Simulate a successful payment most of the time
  const isSuccessful = Math.random() < 0.9;

  if (isSuccessful) {
    return {
      success: true,
      message: 'Payment test successful'
    };
  } else {
    return {
      success: false,
      message: 'Payment test failed. Please try again.'
    };
  }
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\utils\towTruckSelection.js
export const getTowTruckType = (vehicleSize) => {
  switch (vehicleSize) {
    case 'A':
      return 'A';
    case 'B':
      return 'B';
    case 'C':
      return 'C';
    case 'D':
      return 'D';
    default:
      return 'B';
  }
};

export const getTowTruckPricing = (towTruckType) => {
  const pricing = {
    A: { perKm: 18.82, basePrice: 528.69 },
    B: { perKm: 20.62, basePrice: 607.43 },
    C: { perKm: 23.47, basePrice: 721.79 },
    D: { perKm: 32.35, basePrice: 885.84 },
  };
  return pricing[towTruckType] || pricing.B;
};

export const calculateTotalCost = (distance, towTruckType) => {
  const { perKm, basePrice } = getTowTruckPricing(towTruckType);
  const totalCost = basePrice + (distance * perKm);
  return Number(totalCost.toFixed(2)); // Round to 2 decimal places
};


// C:\Users\israe\Documents\GitHub\grua-booking-system-44\src\utils\vehicleData.js
export const vehicleBrands = [
  'Toyota', 'Honda', 'Ford', 'Chevrolet', 'Nissan', 'Volkswagen', 'BMW', 'Mercedes-Benz',
  'Audi', 'Hyundai', 'Mazda', 'Subaru', 'Kia', 'Lexus', 'Volvo', 'Tesla', 'Porsche',
  'Jaguar', 'Land Rover', 'Acura', 'RAM', 'GMC', 'Jeep', 'Dodge', 'Chrysler'
];

export const vehicleModels = {
  Toyota: ['Corolla', 'Camry', 'RAV4', 'Highlander', 'Tacoma', 'Tundra', 'Sienna', 'Prius', 'Land Cruiser', 'C-HR', '4Runner', 'Avalon', 'Venza', 'Sequoia', 'Yaris'],
  Honda: ['Civic', 'Accord', 'CR-V', 'Pilot', 'Odyssey', 'HR-V', 'Fit', 'Ridgeline', 'Insight', 'Passport', 'Clarity', 'Element', 'S2000', 'Crosstour'],
  Ford: ['F-150', 'Mustang', 'Explorer', 'Escape', 'Focus', 'Transit', 'Ranger', 'Edge', 'Expedition', 'Bronco', 'Fusion', 'EcoSport', 'Mach-E', 'Flex', 'GT', 'F-250', 'F-350'],
  Chevrolet: ['Silverado', 'Malibu', 'Equinox', 'Traverse', 'Camaro', 'Corvette', 'Tahoe', 'Suburban', 'Bolt', 'Trax', 'Impala', 'Colorado', 'Blazer', 'Spark', 'Sonic'],
  Nissan: ['Altima', 'Rogue', 'Sentra', 'Maxima', 'Pathfinder', 'Murano', 'Kicks', 'Titan', 'Leaf', 'Versa', 'Armada', 'Frontier', 'GT-R', '370Z', 'Juke'],
  Volkswagen: ['Jetta', 'Passat', 'Tiguan', 'Atlas', 'Golf', 'ID.4', 'Arteon', 'Taos', 'GTI', 'Touareg', 'Beetle', 'CC', 'e-Golf', 'Eos'],
  BMW: ['3 Series', '5 Series', 'X3', 'X5', '7 Series', 'M4', 'X1', 'X7', 'i3', 'Z4', '4 Series', '6 Series', 'X6', 'i8', 'M3'],
  'Mercedes-Benz': ['C-Class', 'E-Class', 'GLC', 'GLE', 'S-Class', 'Sprinter', 'A-Class', 'GLA', 'CLA', 'G-Class', 'GLS', 'CLS', 'SL', 'AMG GT', 'Maybach'],
  Audi: ['A4', 'A6', 'Q5', 'Q7', 'e-tron', 'A3', 'Q3', 'TT', 'R8', 'S4', 'A5', 'Q8', 'RS6', 'A8', 'SQ5'],
  Hyundai: ['Elantra', 'Sonata', 'Tucson', 'Santa Fe', 'Kona', 'Palisade', 'Venue', 'Ioniq', 'Veloster', 'Accent', 'Nexo', 'Azera', 'Genesis', 'Equus'],
  Mazda: ['Mazda3', 'Mazda6', 'CX-5', 'CX-9', 'MX-5 Miata', 'CX-30', 'CX-3', 'CX-50', 'CX-8', 'RX-8', 'CX-7', 'Tribute', '5', '2'],
  Subaru: ['Outback', 'Forester', 'Impreza', 'Crosstrek', 'Legacy', 'Ascent', 'WRX', 'BRZ', 'XV', 'Tribeca', 'Baja', 'SVX'],
  Kia: ['Forte', 'Optima', 'Sportage', 'Sorento', 'Telluride', 'Soul', 'Stinger', 'Seltos', 'Niro', 'Carnival', 'K5', 'Cadenza', 'Rio', 'Sedona'],
  Lexus: ['RX', 'ES', 'NX', 'IS', 'GX', 'UX', 'LS', 'LC', 'RC', 'LX', 'CT', 'GS', 'SC', 'HS'],
  Volvo: ['XC90', 'XC60', 'S60', 'V60', 'XC40', 'S90', 'V90', 'C40', 'S40', 'C30', 'V40', 'S80'],
  Tesla: ['Model 3', 'Model S', 'Model X', 'Model Y', 'Cybertruck', 'Roadster'],
  Porsche: ['911', 'Cayenne', 'Panamera', 'Macan', 'Taycan', 'Boxster', 'Cayman', '718', '944', '928'],
  Jaguar: ['F-PACE', 'XF', 'E-PACE', 'I-PACE', 'XE', 'F-TYPE', 'XJ', 'XK', 'S-Type', 'X-Type'],
  'Land Rover': ['Range Rover', 'Discovery', 'Defender', 'Evoque', 'Velar', 'Freelander', 'LR2', 'LR3', 'LR4'],
  Acura: ['TLX', 'RDX', 'MDX', 'ILX', 'NSX', 'RLX', 'TSX', 'RSX', 'ZDX', 'Integra'],
  RAM: ['1500', '2500', '3500', 'ProMaster', 'ProMaster City'],
  GMC: ['Sierra', 'Yukon', 'Terrain', 'Acadia', 'Canyon', 'Savana'],
  Jeep: ['Wrangler', 'Grand Cherokee', 'Cherokee', 'Compass', 'Renegade', 'Gladiator'],
  Dodge: ['Charger', 'Challenger', 'Durango', 'Journey', 'Grand Caravan'],
  Chrysler: ['300', 'Pacifica', 'Voyager']
};

export const vehicleSizes = {
  A: ['Mustang', 'Camaro', 'Corvette', '911', 'M4', 'BRZ', 'GT-R', '370Z', 'TT', 'F-TYPE', 'Model 3', 'Civic', 'Corolla', 'Mazda3', 'Golf'],
  B: ['RAV4', 'CR-V', 'Explorer', 'Equinox', 'Rogue', 'Tiguan', 'X3', 'GLC', 'Q5', 'Santa Fe', 'Outback', 'Forester'],
  C: ['F-150', 'Silverado', 'RAM 1500', 'Tundra', 'Sierra', 'Tacoma', 'Ranger', 'Colorado', 'Titan', 'Frontier', 'Ridgeline'],
  D: ['F-250', 'F-350', 'Silverado 2500HD', 'RAM 2500', 'RAM 3500', 'Sierra 2500HD', 'Tundra TRD Pro']
};
